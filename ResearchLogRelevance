/**
 * Research Log Relevance Tracking System
 * This extension to the AI Keywords System tracks the relevance of detected entries
 * in the Research_Log and learns from user feedback
 */

// Function to add relevance tracking columns to the Research_Log
function setupResearchLogRelevanceTracking() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      Logger.log("Research_Log sheet not found");
      return false;
    }
    
    // Get the current headers
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Check if relevance columns already exist
    let relevanceColIndex = headers.indexOf("Relevance Score");
    let explanationColIndex = headers.indexOf("Relevance Explanation");
    let learningColIndex = headers.indexOf("Learning Applied");
    
    // If relevance columns don't exist, add them
    if (relevanceColIndex === -1 || explanationColIndex === -1 || learningColIndex === -1) {
      const newHeaders = [...headers];
      
      if (relevanceColIndex === -1) {
        newHeaders.push("Relevance Score");
        relevanceColIndex = newHeaders.length - 1;
      }
      
      if (explanationColIndex === -1) {
        newHeaders.push("Relevance Explanation");
        explanationColIndex = newHeaders.length - 1;
      }
      
      if (learningColIndex === -1) {
        newHeaders.push("Learning Applied");
        learningColIndex = newHeaders.length - 1;
      }
      
      // Update the header row
      sheet.getRange(1, 1, 1, newHeaders.length).setValues([newHeaders]);
      
      // Add data validation for relevance score (0-10)
      // 0 = Not relevant at all (just mentions existing model)
      // 5 = Somewhat relevant (discusses model capabilities)
      // 10 = Highly relevant (announces new model or major update)
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        const scoreRange = sheet.getRange(2, relevanceColIndex + 1, lastRow - 1, 1);
        const rule = SpreadsheetApp.newDataValidation()
          .requireNumberBetween(0, 10)
          .setAllowInvalid(false)
          .setHelpText("Rate relevance: 0 (irrelevant/just mentions existing model), 5 (somewhat relevant), 10 (highly relevant/new model)")
          .build();
        scoreRange.setDataValidation(rule);
      }
      
      // Add color conditional formatting for easy visualization of relevance
      const conditionalFormatting = [
        // Red for low relevance (0-3)
        SpreadsheetApp.newConditionalFormatRule()
          .whenNumberBetween(0, 3)
          .setBackground("#ffcccc")
          .setRanges([sheet.getRange(2, relevanceColIndex + 1, sheet.getMaxRows() - 1, 1)])
          .build(),
        // Yellow for medium relevance (4-7)
        SpreadsheetApp.newConditionalFormatRule()
          .whenNumberBetween(4, 7)
          .setBackground("#ffffcc")
          .setRanges([sheet.getRange(2, relevanceColIndex + 1, sheet.getMaxRows() - 1, 1)])
          .build(),
        // Green for high relevance (8-10)
        SpreadsheetApp.newConditionalFormatRule()
          .whenNumberBetween(8, 10)
          .setBackground("#ccffcc")
          .setRanges([sheet.getRange(2, relevanceColIndex + 1, sheet.getMaxRows() - 1, 1)])
          .build()
      ];
      
      sheet.setConditionalFormatRules(sheet.getConditionalFormatRules().concat(conditionalFormatting));
    }
    
    return {
      relevanceColIndex: relevanceColIndex + 1,
      explanationColIndex: explanationColIndex + 1,
      learningColIndex: learningColIndex + 1
    };
  } catch (error) {
    Logger.log(`Error setting up Research Log relevance tracking: ${error.message}`);
    return false;
  }
}
/**
 * Apply learning from relevance scores to improve keyword detection
 * This function analyzes the Research_Log entries with relevance scores
 * and identifies patterns in keywords that led to low/high relevance results
 */
function applyRelevanceLearningToKeywords() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get column indices
    const columns = setupResearchLogRelevanceTracking();
    if (!columns) {
      throw new Error("Failed to set up relevance tracking columns");
    }
    
    // Get all data
    const data = sheet.getDataRange().getValues();
    const headerRow = data[0];
    
    // Map column names to indices
    // This approach is more flexible and will work even if column order changes
    const columnMap = {};
    headerRow.forEach((header, index) => {
      columnMap[header] = index;
    });
    
    // Check for required columns using the column map
    const resultsColIndex = columnMap["Results"];
    const relevanceColIndex = columns.relevanceColIndex - 1; // Convert to 0-based index
    const explanationColIndex = columns.explanationColIndex - 1;
    const learningColIndex = columns.learningColIndex - 1;
    
    if (resultsColIndex === undefined) {
      throw new Error("Required column 'Results' not found in Research_Log");
    }
    
    // Statistics tracking
    const keywordStats = {
      highRelevance: {}, // Keywords that appear in high relevance entries
      lowRelevance: {},  // Keywords that appear in low relevance entries
      patterns: []       // Patterns identified from explanations
    };
    
    // Process each row (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const relevanceScore = row[relevanceColIndex] ? Number(row[relevanceColIndex]) : null;
      const explanation = row[explanationColIndex] || "";
      const learningApplied = row[learningColIndex] || "";
      
      // Skip rows without relevance scores
      if (relevanceScore === null) continue;
      
      // Get content from Results column
      const content = row[resultsColIndex] || "";
      
      // Also check Notes column if it exists
      const notesColIndex = columnMap["Notes"];
      const notes = notesColIndex !== undefined ? row[notesColIndex] || "" : "";
      
      // Combine content from Results and Notes for better keyword extraction
      const combinedContent = content + " " + notes;
      
      // Extract potential keywords from content
      // This replaces the need for the "Detected Keywords" column
      const keywordList = extractKeywordsFromContent(combinedContent);
      
      // Categorize by relevance
      const relevanceCategory = relevanceScore >= 8 ? "highRelevance" : 
                              relevanceScore <= 3 ? "lowRelevance" : null;
      
      if (relevanceCategory && keywordList.length > 0) {
        for (const keyword of keywordList) {
          if (!keywordStats[relevanceCategory][keyword]) {
            keywordStats[relevanceCategory][keyword] = 0;
          }
          keywordStats[relevanceCategory][keyword]++;
        }
      }
      
      // Extract potential model names from "Article" mentions in the content
      const articleMatches = content.match(/Article: "([^"]+)"/);
      if (articleMatches && articleMatches[1]) {
        const articleTitle = articleMatches[1].trim();
        // Add the article title as a potential keyword
        if (relevanceCategory) {
          if (!keywordStats[relevanceCategory][articleTitle]) {
            keywordStats[relevanceCategory][articleTitle] = 0;
          }
          keywordStats[relevanceCategory][articleTitle]++;
        }
      }
      
      // Extract patterns from explanations
      if (explanation) {
        // Look for patterns in the explanation
        const patternMatches = [
          ...explanation.matchAll(/(?:because|due to|contains?)\s+["']([^"']+)["']/gi),
          ...explanation.matchAll(/mentions?\s+["']([^"']+)["']/gi),
          ...explanation.matchAll(/(?:high|low)\s+relevance\s+(?:due to|because of)\s+["']([^"']+)["']/gi)
        ];
        
        for (const match of patternMatches) {
          if (match[1]) {
            keywordStats.patterns.push({
              pattern: match[1].trim(),
              relevanceScore: relevanceScore,
              explanation: explanation
            });
          }
        }
      }
      
      // Mark this row as having learning applied
      if (relevanceScore !== null && learningApplied === "") {
        sheet.getRange(i+1, columns.learningColIndex).setValue("Applied");
      }
    }
    
    // Process the collected statistics
    // Instead of calling getAIKeywords() which might not be available, skip that line
    // const aiKeywords = getAIKeywords();  // This may cause an error if function isn't available
    let report = "Relevance Learning Analysis:\n\n";
    
    // Find keywords that are consistently in high-relevance entries
    const highRelevanceKeywords = Object.entries(keywordStats.highRelevance)
      .filter(([_, count]) => count >= 2)  // Appear in at least 2 high-relevance entries
      .sort((a, b) => b[1] - a[1]);        // Sort by frequency
    
    // Find keywords that are consistently in low-relevance entries
    const lowRelevanceKeywords = Object.entries(keywordStats.lowRelevance)
      .filter(([_, count]) => count >= 3)  // Appear in at least 3 low-relevance entries
      .sort((a, b) => b[1] - a[1]);        // Sort by frequency
    
    // Generate report for high-relevance keywords
    if (highRelevanceKeywords.length > 0) {
      report += "High-Relevance Keywords:\n";
      for (const [keyword, count] of highRelevanceKeywords) {
        report += `  - "${keyword}" (Found in ${count} high-relevance entries)\n`;
      }
      report += "\n";
    }
    
    // Generate report for low-relevance keywords
    if (lowRelevanceKeywords.length > 0) {
      report += "Low-Relevance Keywords (Consider refining these):\n";
      for (const [keyword, count] of lowRelevanceKeywords) {
        report += `  - "${keyword}" (Found in ${count} low-relevance entries)\n`;
        
        // Try to find a better version of this keyword based on patterns
        const potentialImprovements = keywordStats.patterns
          .filter(p => p.relevanceScore >= 8 && p.pattern.includes(keyword))
          .map(p => p.pattern);
        
        if (potentialImprovements.length > 0) {
          report += `      Consider replacing with more specific patterns like: ${potentialImprovements.join(", ")}\n`;
        }
      }
      report += "\n";
    }
    
    // Analyze explanations for actionable patterns
    if (keywordStats.patterns.length > 0) {
      report += "Patterns Extracted from Explanations:\n";
      
      // Group by relevance range
      const highPatterns = keywordStats.patterns.filter(p => p.relevanceScore >= 8);
      const lowPatterns = keywordStats.patterns.filter(p => p.relevanceScore <= 3);
      
      if (highPatterns.length > 0) {
        report += "  Patterns in High-Relevance Entries:\n";
        for (const pattern of highPatterns.slice(0, 5)) { // Limit to top 5
          report += `    - "${pattern.pattern}" (Score: ${pattern.relevanceScore})\n`;
        }
      }
      
      if (lowPatterns.length > 0) {
        report += "  Patterns in Low-Relevance Entries (consider excluding):\n";
        for (const pattern of lowPatterns.slice(0, 5)) { // Limit to top 5
          report += `    - "${pattern.pattern}" (Score: ${pattern.relevanceScore})\n`;
        }
      }
    }
    
    // Create a summary sheet with detailed findings
    const summarySheet = ss.getSheetByName("Relevance_Learning") || ss.insertSheet("Relevance_Learning");
    summarySheet.clear();
    
    // Add summary headers
    summarySheet.getRange(1, 1, 1, 3).setValues([["Keyword/Pattern", "Relevance Category", "Frequency/Score"]]);
    summarySheet.getRange(1, 1, 1, 3).setFontWeight("bold");
    
    // Add high relevance keywords
    let rowIndex = 2;
    for (const [keyword, count] of highRelevanceKeywords) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([[keyword, "High Relevance", count]]);
      summarySheet.getRange(rowIndex, 2).setBackground("#ccffcc"); // Green
      rowIndex++;
    }
    
    // Add low relevance keywords
    for (const [keyword, count] of lowRelevanceKeywords) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([[keyword, "Low Relevance", count]]);
      summarySheet.getRange(rowIndex, 2).setBackground("#ffcccc"); // Red
      rowIndex++;
    }
    
    // Add some space
    rowIndex += 2;
    
    // Add pattern headers
    summarySheet.getRange(rowIndex, 1, 1, 3).setValues([["Extracted Pattern", "Relevance Score", "Explanation"]]);
    summarySheet.getRange(rowIndex, 1, 1, 3).setFontWeight("bold");
    rowIndex++;
    
    // Add patterns
    for (const pattern of keywordStats.patterns) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([
        [pattern.pattern, pattern.relevanceScore, pattern.explanation]
      ]);
      
      // Color based on relevance
      if (pattern.relevanceScore >= 8) {
        summarySheet.getRange(rowIndex, 2).setBackground("#ccffcc"); // Green
      } else if (pattern.relevanceScore <= 3) {
        summarySheet.getRange(rowIndex, 2).setBackground("#ffcccc"); // Red
      } else {
        summarySheet.getRange(rowIndex, 2).setBackground("#ffffcc"); // Yellow
      }
      
      rowIndex++;
    }
    
    // Autosize columns
    summarySheet.autoResizeColumns(1, 3);
    
    // Create filter
    try {
      const filter = summarySheet.getFilter();
      if (filter) {
        filter.remove();
      }
      summarySheet.getRange(1, 1, rowIndex - 1, 3).createFilter();
    } catch (e) {
      Logger.log("Could not create filter, but analysis was completed successfully");
    }
    
    // Display the report
    const ui = SpreadsheetApp.getUi();
    ui.alert('Research Log Relevance Analysis', report, ui.ButtonSet.OK);
    
    return true;
  } catch (error) {
    Logger.log(`Error applying relevance learning: ${error.message}`);
    const ui = SpreadsheetApp.getUi();
    ui.alert('Error', `Failed to apply relevance learning: ${error.message}`, ui.ButtonSet.OK);
    return false;
  }
}

/**
 * Helper function to extract potential keywords from content
 * This replaces the need for a "Detected Keywords" column
 */
function extractKeywordsFromContent(content) {
  // List of AI model names and keywords to look for
  const aiModels = [
    "GPT", "GPT-3", "GPT-4", "GPT-4.5", "GPT-5", "GPT-4o",
    "Claude", "Claude 2", "Claude 3", "Claude 3.5", "Claude 3.7", "Opus", "Sonnet", "Haiku",
    "Gemini", "Gemini Pro", "Gemini Ultra", "Gemini 1.5", 
    "Llama", "Llama 2", "Llama 3",
    "Mistral", "Mixtral", "Phi-3", "Anthropic", "OpenAI", "Google", "Meta",
    "Bard", "PaLM", "Copilot", "Stability AI", "DALL-E", "Midjourney",
    "Sora", "Devin", "Grok", "Inflection", "Xi", "Mamba"
  ];
  
  // Extract potential keywords that appear in the content
  const keywordList = [];
  const contentLower = content.toLowerCase();
  
  for (const model of aiModels) {
    if (contentLower.includes(model.toLowerCase())) {
      keywordList.push(model);
    }
  }
  
  // Look for model-related keywords
  const relevantPhrases = [
    "new model", "released", "announcement", "launch", "introduces", 
    "unveils", "breakthrough", "state-of-the-art", "SOTA", "open source",
    "API", "available", "production", "enterprise", "free tier", "pricing",
    "rollout", "expanding access", "multimodal", "reasoning", "agentic",
    "code interpreter", "streaming", "on-device", "autonomous agent"
  ];
  
  for (const phrase of relevantPhrases) {
    if (contentLower.includes(phrase.toLowerCase())) {
      keywordList.push(phrase);
    }
  }
  
  // Extract potential model mentions from article titles/descriptions
  // Look for patterns like "found: MODEL from COMPANY"
  const modelMatches = content.match(/found: ([\w\s\.-]+) from ([\w\s]+)/g);
  if (modelMatches) {
    for (const match of modelMatches) {
      const parts = match.split("from");
      if (parts.length === 2) {
        const modelName = parts[0].replace("found:", "").trim();
        keywordList.push(modelName);
      }
    }
  }
  
  return keywordList;
}

/**
 * Sets up menus for Research Log functionality
 * This renamed function will be called from the main onOpen function
 */
function setupResearchLogMenus() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addToUi();
  } catch (e) {
    Logger.log('Error creating Research Log menu: ' + e.message);
  }
}

/**
 * Automatically run this when a new entry is added to the Research Log
 * This can be set up as a trigger or called from your existing code
 * @param {number} row - The row number of the new entry
 */
function prepareNewResearchLogEntry(row) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) return;
    
    // Ensure the relevance columns exist
    const columns = setupResearchLogRelevanceTracking();
    if (!columns) return;
    
    // Get the header row to find content column
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const contentColIndex = headers.indexOf("Content") + 1;
    
    if (contentColIndex === 0) return;
    
    // Get the content from the specified row
    const content = sheet.getRange(row, contentColIndex).getValue();
    
    // Make an initial assessment of relevance based on known patterns
    let initialRelevanceScore = 5; // Default to medium relevance
    let initialExplanation = "";
    
    // Check for patterns that typically indicate high relevance
    const highRelevancePatterns = [
      /\bannounces?\b.{1,50}\bnew\b.{1,50}\bmodel\b/i,
      /\breleas(?:e|es|ed|ing)\b.{1,50}\bnew\b/i,
      /\blaunch(?:es|ed|ing)?\b.{1,40}\bmodel\b/i,
      /\bupgrad(?:e|es|ed|ing)\b.{1,30}\bto\b/i,
      /\bbreakthrough\b/i,
      /\bstate-of-the-art\b|\bsota\b/i,
      /\bopen-sourc(?:e|ed|ing)\b/i
    ];
    
    // Check for patterns that typically indicate low relevance
    const lowRelevancePatterns = [
      /\busing\b.{1,30}\b(gpt|claude|gemini|llama)\b/i,
      /\bprompt(?:s|ing)?\b.{1,30}\b(gpt|claude|gemini|llama)\b/i,
      /\bgenerat(?:e|ed|es|ing)\b.{1,30}\busing\b/i,
      /\breview of\b/i,
      /\btutorial\b/i,
      /\bhow to use\b/i,
      /\bcomparing\b/i
    ];
    
    // Check for high relevance patterns
    for (const pattern of highRelevancePatterns) {
      if (pattern.test(content)) {
        initialRelevanceScore = 8;
        initialExplanation = "Auto-detected potential high relevance: Contains pattern indicating new model release or breakthrough";
        break;
      }
    }
    
    // Check for low relevance patterns
    for (const pattern of lowRelevancePatterns) {
      if (pattern.test(content)) {
        initialRelevanceScore = 3;
        initialExplanation = "Auto-detected potential low relevance: Contains pattern indicating usage guide or tutorial";
        break;
      }
    }
    
    // Set the initial relevance and explanation
    sheet.getRange(row, columns.relevanceColIndex).setValue(initialRelevanceScore);
    sheet.getRange(row, columns.explanationColIndex).setValue(initialExplanation);
  } catch (error) {
    Logger.log(`Error preparing new Research Log entry: ${error.message}`);
  }
}

/**
 * Simple trigger to run this for the active cell's row when the user selects
 * the option from the menu or when a new entry is added
 */
function prepareCurrentEntryRelevance() {
  const sheet = SpreadsheetApp.getActiveSheet();
  if (sheet.getName() !== "Research_Log") {
    SpreadsheetApp.getUi().alert("Please select a cell in the Research_Log sheet");
    return;
  }
  
  const row = sheet.getActiveCell().getRow();
  if (row > 1) { // Skip header row
    prepareNewResearchLogEntry(row);
    SpreadsheetApp.getUi().alert("Initial relevance assessment applied to this entry");
  }
}
/**
 * Improved function to extract article URLs from XML/RSS feeds
 * This version focuses on matching titles more accurately
 */
function extractArticleURLsImproved() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      SpreadsheetApp.getUi().alert("Research_Log sheet not found");
      return false;
    }
    
    // Get all data
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const urlColIndex = headers.indexOf("URL");
    const typeColIndex = headers.indexOf("Type");
    const resultsColIndex = headers.indexOf("Results");
    
    if (urlColIndex === -1 || typeColIndex === -1 || resultsColIndex === -1) {
      SpreadsheetApp.getUi().alert("Required columns not found. Please make sure URL, Type, and Results columns exist.");
      return false;
    }
    
    // Create a new column for Article URL if it doesn't exist
    let articleUrlColIndex = headers.indexOf("Article URL");
    if (articleUrlColIndex === -1) {
      // Add the new column header after the URL column
      sheet.insertColumnAfter(urlColIndex + 1);
      sheet.getRange(1, urlColIndex + 2).setValue("Article URL");
      articleUrlColIndex = urlColIndex + 1;
    } else {
      // Convert from 0-based index to column number
      articleUrlColIndex = articleUrlColIndex;
    }
    
    // Track processed URLs to avoid duplicates
    const processedFeeds = {};
    
    // Create a counter for modified entries
    let modifiedCount = 0;
    
    // Process each row (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const feedUrl = row[urlColIndex];
      const type = row[typeColIndex];
      const results = row[resultsColIndex];
      
      // Skip if no URL or not an RSS Feed
      if (!feedUrl || type !== "RSS Feed") continue;
      
      try {
        // Extract the article title from the Results column
        let articleTitle = "";
        if (results && results.toString().includes("Article:")) {
          const match = results.toString().match(/Article: "(.*?)"/);
          if (match && match[1]) {
            articleTitle = match[1].trim();
          }
        }
        
        // Skip if no article title
        if (!articleTitle) continue;
        
        // Try to fetch the feed content (only once per unique feed URL)
        let content = "";
        if (!processedFeeds[feedUrl]) {
          try {
            const response = UrlFetchApp.fetch(feedUrl, { muteHttpExceptions: true });
            if (response.getResponseCode() === 200) {
              content = response.getContentText();
              processedFeeds[feedUrl] = content;
            } else {
              Logger.log(`Error fetching URL ${feedUrl}: Status code ${response.getResponseCode()}`);
              continue;
            }
          } catch (e) {
            Logger.log(`Error fetching URL ${feedUrl}: ${e.message}`);
            continue;
          }
        } else {
          content = processedFeeds[feedUrl];
        }
        
        if (!content) continue;
        
        // Find the best matching article URL based on title
        let articleUrl = findBestMatchingArticle(content, articleTitle, feedUrl);
        
        // If we found an article URL, update the cell
        if (articleUrl) {
          sheet.getRange(i + 1, articleUrlColIndex + 1).setValue(articleUrl);
          modifiedCount++;
        }
      } catch (rowError) {
        Logger.log(`Error processing row ${i+1}: ${rowError.message}`);
        continue;
      }
    }
    
    SpreadsheetApp.getUi().alert(`Updated ${modifiedCount} article URLs in the Research_Log sheet.`);
    return true;
  } catch (error) {
    Logger.log(`Error extracting article URLs: ${error.message}`);
    SpreadsheetApp.getUi().alert(`Error: ${error.message}`);
    return false;
  }
}

/**
 * Helper function to find the best matching article in a feed
 * based on the article title
 */
function findBestMatchingArticle(content, articleTitle, feedUrl) {
  // Normalize the article title for better matching
  const normalizedTitle = normalizeTitle(articleTitle);
  
  // Different parsing strategies based on feed type
  if (feedUrl.includes("techcrunch.com")) {
    return findTechCrunchArticle(content, normalizedTitle);
  } else if (feedUrl.includes("venturebeat.com")) {
    return findVentureBeatArticle(content, normalizedTitle);
  } else if (feedUrl.includes("zdnet.com")) {
    return findZDNetArticle(content, normalizedTitle);
  } else if (feedUrl.includes("technologyreview.com")) {
    return findMITTechReviewArticle(content, normalizedTitle);
  } else {
    return findGenericRssArticle(content, normalizedTitle);
  }
}

/**
 * Normalize a title for better matching
 */
function normalizeTitle(title) {
  return title.toLowerCase()
    .replace(/[^\w\s]/g, '') // Remove punctuation
    .replace(/\s+/g, ' ')    // Normalize whitespace
    .trim();
}

/**
 * Calculate similarity between two strings (0-1)
 * Higher value means more similar
 */
function calculateSimilarity(str1, str2) {
  const s1 = normalizeTitle(str1);
  const s2 = normalizeTitle(str2);
  
  // Simple word overlap score
  const words1 = s1.split(' ');
  const words2 = s2.split(' ');
  
  let matchCount = 0;
  for (const word of words1) {
    if (word.length > 3 && words2.includes(word)) { // Only count meaningful words
      matchCount++;
    }
  }
  
  // Calculate overlap score
  return matchCount / Math.max(words1.length, words2.length);
}

/**
 * Extract TechCrunch article URL
 */
function findTechCrunchArticle(content, normalizedTitle) {
  // Extract all item blocks
  const itemMatches = content.match(/<item>[\s\S]*?<\/item>/g);
  if (!itemMatches) return null;
  
  let bestMatch = null;
  let bestScore = 0;
  
  for (const item of itemMatches) {
    // Extract title
    const titleMatch = item.match(/<title>(.*?)<\/title>/);
    if (!titleMatch || !titleMatch[1]) continue;
    
    // Clean title
    const itemTitle = titleMatch[1]
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")
      .trim();
    
    // Calculate similarity
    const similarity = calculateSimilarity(itemTitle, normalizedTitle);
    
    // Extract link
    const linkMatch = item.match(/<link>(.*?)<\/link>/);
    if (!linkMatch || !linkMatch[1]) continue;
    
    const link = linkMatch[1].trim();
    
    // Update best match if this is better
    if (similarity > bestScore) {
      bestScore = similarity;
      bestMatch = link;
    }
  }
  
  // Only return if we have a reasonably good match
  return bestScore > 0.3 ? bestMatch : null;
}

/**
 * Extract VentureBeat article URL
 */
function findVentureBeatArticle(content, normalizedTitle) {
  // Extract all item blocks
  const itemMatches = content.match(/<item>[\s\S]*?<\/item>/g);
  if (!itemMatches) return null;
  
  let bestMatch = null;
  let bestScore = 0;
  
  for (const item of itemMatches) {
    // Extract title
    const titleMatch = item.match(/<title>(.*?)<\/title>/);
    if (!titleMatch || !titleMatch[1]) continue;
    
    // Clean title
    const itemTitle = titleMatch[1]
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")
      .trim();
    
    // Calculate similarity
    const similarity = calculateSimilarity(itemTitle, normalizedTitle);
    
    // Extract link
    const linkMatch = item.match(/<link>(.*?)<\/link>/);
    if (!linkMatch || !linkMatch[1]) continue;
    
    const link = linkMatch[1].trim();
    
    // Update best match if this is better
    if (similarity > bestScore) {
      bestScore = similarity;
      bestMatch = link;
    }
  }
  
  // Only return if we have a reasonably good match
  return bestScore > 0.3 ? bestMatch : null;
}

/**
 * Extract ZDNet article URL
 */
function findZDNetArticle(content, normalizedTitle) {
  // For ZDNet, the structure is different
  // Extract all entry blocks which is common in Atom feeds
  const entryMatches = content.match(/<entry>[\s\S]*?<\/entry>/g);
  if (!entryMatches) return null;
  
  let bestMatch = null;
  let bestScore = 0;
  
  for (const entry of entryMatches) {
    // Extract title
    const titleMatch = entry.match(/<title.*?>(.*?)<\/title>/);
    if (!titleMatch || !titleMatch[1]) continue;
    
    // Clean title
    const entryTitle = titleMatch[1]
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")
      .trim();
    
    // Calculate similarity
    const similarity = calculateSimilarity(entryTitle, normalizedTitle);
    
    // Extract link - ZDNet often uses link tags with attributes
    const linkMatch = entry.match(/<link.*?href="(.*?)".*?\/>/);
    if (!linkMatch || !linkMatch[1]) continue;
    
    const link = linkMatch[1].trim();
    
    // Update best match if this is better
    if (similarity > bestScore) {
      bestScore = similarity;
      bestMatch = link;
    }
  }
  
  // Only return if we have a reasonably good match
  return bestScore > 0.3 ? bestMatch : null;
}

/**
 * Extract MIT Technology Review article URL
 */
function findMITTechReviewArticle(content, normalizedTitle) {
  // Extract all item blocks
  const itemMatches = content.match(/<item>[\s\S]*?<\/item>/g);
  if (!itemMatches) return null;
  
  let bestMatch = null;
  let bestScore = 0;
  
  for (const item of itemMatches) {
    // Extract title
    const titleMatch = item.match(/<title>(.*?)<\/title>/);
    if (!titleMatch || !titleMatch[1]) continue;
    
    // Clean title
    const itemTitle = titleMatch[1]
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")
      .trim();
    
    // Calculate similarity
    const similarity = calculateSimilarity(itemTitle, normalizedTitle);
    
    // Extract link
    const linkMatch = item.match(/<link>(.*?)<\/link>/) || 
                     item.match(/<guid isPermaLink="true">(.*?)<\/guid>/);
    
    if (!linkMatch || !linkMatch[1]) continue;
    
    const link = linkMatch[1].trim();
    
    // Update best match if this is better
    if (similarity > bestScore) {
      bestScore = similarity;
      bestMatch = link;
    }
  }
  
  // Only return if we have a reasonably good match
  return bestScore > 0.3 ? bestMatch : null;
}

/**
 * Extract article URL from a generic RSS feed
 */
function findGenericRssArticle(content, normalizedTitle) {
  // Try different formats
  const itemMatches = content.match(/<item>[\s\S]*?<\/item>/g) || 
                     content.match(/<entry>[\s\S]*?<\/entry>/g);
  
  if (!itemMatches) return null;
  
  let bestMatch = null;
  let bestScore = 0;
  
  for (const item of itemMatches) {
    // Try different title formats
    const titleMatch = item.match(/<title.*?>(.*?)<\/title>/) || 
                      item.match(/<title type="html">(.*?)<\/title>/);
    
    if (!titleMatch || !titleMatch[1]) continue;
    
    // Clean title
    const itemTitle = titleMatch[1]
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1")
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#039;/g, "'")
      .trim();
    
    // Calculate similarity
    const similarity = calculateSimilarity(itemTitle, normalizedTitle);
    
    // Try different link formats
    const linkMatch = item.match(/<link>(.*?)<\/link>/) || 
                     item.match(/<link.*?href="(.*?)".*?>/) ||
                     item.match(/<guid isPermaLink="true">(.*?)<\/guid>/) ||
                     item.match(/<link rel="alternate".*?href="(.*?)".*?>/);
    
    if (!linkMatch || !linkMatch[1]) continue;
    
    const link = linkMatch[1].trim();
    
    // Update best match if this is better
    if (similarity > bestScore) {
      bestScore = similarity;
      bestMatch = link;
    }
  }
  
  // Only return if we have a reasonably good match
  return bestScore > 0.3 ? bestMatch : null;
}

/**
 * Update the setupResearchLogMenus function to include the improved URL extraction
 */
function setupResearchLogMenus() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addSeparator()
      .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved')
      .addItem('Make URLs Clickable', 'makeArticleUrlsClickable')
      .addToUi();
  } catch (e) {
    Logger.log('Error creating Research Log menu: ' + e.message);
  }
}
/**
 * Predicts the relevance score of a new article based on learned patterns
 * This can be used to pre-score articles before adding them to the Research Log
 * 
 * @param {string} articleTitle - The title of the article
 * @param {string} articleContent - The content or summary of the article
 * @param {Object} options - Optional configuration
 * @param {boolean} options.detailed - Whether to return detailed explanation (default: false)
 * @return {Object} - Prediction result with score and explanation
 */
function predictArticleRelevance(articleTitle, articleContent, options = {}) {
  const detailed = options.detailed || false;
  
  try {
    // Get the spreadsheet and locate the Relevance_Learning sheet
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const learningSheet = ss.getSheetByName("Relevance_Learning");
    
    if (!learningSheet) {
      throw new Error("Relevance_Learning sheet not found. Please run 'Apply Relevance Learning' first.");
    }
    
    // Get learned patterns from the sheet
    const learningData = learningSheet.getDataRange().getValues();
    const headers = learningData[0];
    
    // Find column indices
    const keywordColIndex = headers.indexOf("Keyword/Pattern");
    const categoryColIndex = headers.indexOf("Relevance Category");
    const scoreColIndex = headers.indexOf("Frequency/Score");
    
    if (keywordColIndex === -1 || categoryColIndex === -1) {
      throw new Error("Required columns not found in Relevance_Learning sheet");
    }
    
    // Collect high and low relevance patterns
    const highRelevancePatterns = [];
    const lowRelevancePatterns = [];
    const extractedPatterns = [];
    
    let patternSectionFound = false;
    
    // Process rows (skip header)
    for (let i = 1; i < learningData.length; i++) {
      const row = learningData[i];
      
      // Skip empty rows
      if (!row[keywordColIndex]) continue;
      
      // Check if we've reached the extracted patterns section
      if (row[keywordColIndex] === "Extracted Pattern") {
        patternSectionFound = true;
        continue;
      }
      
      if (patternSectionFound) {
        // Process extracted patterns section
        const pattern = row[keywordColIndex];
        const score = row[scoreColIndex] ? Number(row[scoreColIndex]) : 0;
        
        if (pattern) {
          extractedPatterns.push({
            pattern: pattern,
            score: score
          });
        }
      } else {
        // Process keyword section
        const keyword = row[keywordColIndex];
        const category = row[categoryColIndex];
        const frequency = row[scoreColIndex] ? Number(row[scoreColIndex]) : 0;
        
        if (keyword && category) {
          if (category.includes("High Relevance")) {
            highRelevancePatterns.push({
              keyword: keyword,
              frequency: frequency
            });
          } else if (category.includes("Low Relevance")) {
            lowRelevancePatterns.push({
              keyword: keyword,
              frequency: frequency
            });
          }
        }
      }
    }
    
    // Define contextual patterns that indicate high relevance
    const highRelevanceContexts = [
      /\bannounces?\b.{1,50}\bnew\b.{1,50}\bmodel\b/i,
      /\breleas(?:e|es|ed|ing)\b.{1,50}\bnew\b/i,
      /\blaunch(?:es|ed|ing)?\b.{1,40}\bmodel\b/i,
      /\bupgrad(?:e|es|ed|ing)\b.{1,30}\bto\b/i,
      /\bbreakthrough\b/i,
      /\bstate-of-the-art\b|\bsota\b/i,
      /\bopen-sourc(?:e|ed|ing)\b/i,
      /\bexpand(?:s|ing|ed)?\s+access\b/i,
      /\bnow available\b/i,
      /\bpublic\s+release\b/i
    ];
    
    // Define contextual patterns that indicate low relevance
    const lowRelevanceContexts = [
      /\busing\b.{1,30}\b(gpt|claude|gemini|llama)\b/i,
      /\bprompt(?:s|ing)?\b.{1,30}\b(gpt|claude|gemini|llama)\b/i,
      /\bgenerat(?:e|ed|es|ing)\b.{1,30}\busing\b/i,
      /\breview of\b/i,
      /\btutorial\b/i,
      /\bhow to use\b/i,
      /\bcomparing\b/i,
      /\bgenerat(?:e|ed|es|ing) with\b/i,
      /\btips\s+for\s+better\b/i
    ];
    
    // Combine title and content for analysis
    const fullText = `${articleTitle} ${articleContent}`;
    
    // Initialize scores
    let relevanceScore = 5; // Start with medium relevance
    let highPatternCount = 0;
    let lowPatternCount = 0;
    
    // Score tracking for detailed explanation
    const scoreFactors = {
      highRelevanceKeywords: [],
      lowRelevanceKeywords: [],
      highRelevanceContexts: [],
      lowRelevanceContexts: [],
      extractedPatterns: []
    };
    
    // Check for high relevance keywords
    for (const pattern of highRelevancePatterns) {
      const regex = new RegExp(`\\b${escapeRegExp(pattern.keyword)}\\b`, 'i');
      if (regex.test(fullText)) {
        relevanceScore += Math.min(pattern.frequency, 2);
        highPatternCount++;
        
        if (detailed) {
          scoreFactors.highRelevanceKeywords.push({
            keyword: pattern.keyword,
            impact: `+${Math.min(pattern.frequency, 2)}`
          });
        }
      }
    }
    
    // Check for low relevance keywords
    for (const pattern of lowRelevancePatterns) {
      const regex = new RegExp(`\\b${escapeRegExp(pattern.keyword)}\\b`, 'i');
      if (regex.test(fullText)) {
        relevanceScore -= Math.min(pattern.frequency, 2);
        lowPatternCount++;
        
        if (detailed) {
          scoreFactors.lowRelevanceKeywords.push({
            keyword: pattern.keyword,
            impact: `-${Math.min(pattern.frequency, 2)}`
          });
        }
      }
    }
    
    // Check for high relevance contexts
    for (let i = 0; i < highRelevanceContexts.length; i++) {
      if (highRelevanceContexts[i].test(fullText)) {
        relevanceScore += 2;
        highPatternCount++;
        
        if (detailed) {
          scoreFactors.highRelevanceContexts.push({
            context: highRelevanceContexts[i].toString(),
            impact: "+2"
          });
        }
      }
    }
    
    // Check for low relevance contexts
    for (let i = 0; i < lowRelevanceContexts.length; i++) {
      if (lowRelevanceContexts[i].test(fullText)) {
        relevanceScore -= 2;
        lowPatternCount++;
        
        if (detailed) {
          scoreFactors.lowRelevanceContexts.push({
            context: lowRelevanceContexts[i].toString(),
            impact: "-2"
          });
        }
      }
    }
    
    // Check for extracted patterns
    for (const pattern of extractedPatterns) {
      const regex = new RegExp(`\\b${escapeRegExp(pattern.pattern)}\\b`, 'i');
      if (regex.test(fullText)) {
        // Adjust score based on the pattern's score
        const impact = pattern.score >= 8 ? 2 : pattern.score <= 3 ? -2 : 0;
        relevanceScore += impact;
        
        if (impact > 0) highPatternCount++;
        if (impact < 0) lowPatternCount++;
        
        if (detailed) {
          scoreFactors.extractedPatterns.push({
            pattern: pattern.pattern,
            score: pattern.score,
            impact: impact > 0 ? `+${impact}` : impact
          });
        }
      }
    }
    
    // Look for new model announcements in specific formats
    const newModelPatterns = [
      /released\s+(?:a\s+)?new\s+(?:version|model)/i,
      /announced\s+(?:a\s+)?new\s+(?:version|model)/i,
      /introduces\s+(?:a\s+)?new\s+(?:version|model)/i,
      /launching\s+(?:a\s+)?new\s+(?:version|model)/i,
      /version\s+[\d\.]+\s+is\s+(?:now\s+)?available/i,
      /expanding\s+access\s+to/i
    ];
    
    for (const pattern of newModelPatterns) {
      if (pattern.test(fullText)) {
        relevanceScore += 3;
        highPatternCount++;
        
        if (detailed) {
          scoreFactors.highRelevanceContexts.push({
            context: pattern.toString(),
            impact: "+3"
          });
        }
      }
    }
    
    // Ensure score stays within bounds
    relevanceScore = Math.max(0, Math.min(10, relevanceScore));
    
    // Generate prediction text based on the score
    let predictionText = "";
    if (relevanceScore >= 8) {
      predictionText = "High Relevance: Likely announces a new model or significant update";
    } else if (relevanceScore >= 4) {
      predictionText = "Medium Relevance: Discusses AI model capabilities or features";
    } else {
      predictionText = "Low Relevance: Likely just mentions models without significant news";
    }
    
    // Prepare the result
    const result = {
      score: relevanceScore,
      prediction: predictionText,
      confidence: calculateConfidence(highPatternCount, lowPatternCount)
    };
    
    // Add detailed explanation if requested
    if (detailed) {
      result.explanation = {
        baseScore: 5,
        factors: scoreFactors,
        summary: `Final relevance score: ${relevanceScore.toFixed(1)} (${result.confidence}% confidence)`
      };
    }
    
    return result;
    
  } catch (error) {
    Logger.log(`Error in predictArticleRelevance: ${error.message}`);
    return {
      score: 5,
      prediction: "Error: Could not predict relevance. " + error.message,
      confidence: 0
    };
  }
}

/**
 * Utility to escape special regex characters in a string
 */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Calculate confidence percentage based on pattern matches
 */
function calculateConfidence(highCount, lowCount) {
  const totalPatterns = highCount + lowCount;
  
  if (totalPatterns === 0) return 20; // Low confidence if no patterns match
  if (totalPatterns === 1) return 40; // Limited confidence with only one match
  if (totalPatterns >= 5) return 95; // High confidence with many matches
  
  // Scale from 50% to 90% based on number of matches
  return Math.min(50 + (totalPatterns * 10), 90);
}

/**
 * Test function to demonstrate usage with a sample article
 */
function testRelevancePrediction() {
  // Example article with a new model announcement
  const highRelevanceExample = {
    title: "OpenAI Releases GPT-4.5 with Enhanced Reasoning Capabilities",
    content: "OpenAI has announced the release of GPT-4.5, the latest version of their flagship language model. This new model features significant improvements in reasoning, factual accuracy, and code generation capabilities. GPT-4.5 will be available to all paying customers starting next week, with a wider rollout planned for next month."
  };
  
  // Example article that just mentions models
  const lowRelevanceExample = {
    title: "How to Write Better Prompts for ChatGPT and Claude",
    content: "This guide explores effective prompt engineering techniques for popular AI models like ChatGPT and Claude. Learn how to structure your queries to get more accurate and helpful responses from these language models. We'll cover examples using GPT-4 and Claude 3 Opus."
  };
  
  // Test with both examples
  const highRelevanceResult = predictArticleRelevance(highRelevanceExample.title, highRelevanceExample.content, { detailed: true });
  const lowRelevanceResult = predictArticleRelevance(lowRelevanceExample.title, lowRelevanceExample.content, { detailed: true });
  
  // Display results
  const ui = SpreadsheetApp.getUi();
  ui.alert(
    'Relevance Prediction Test Results',
    `Example 1 (New Model Announcement):\n` +
    `Score: ${highRelevanceResult.score}\n` +
    `Prediction: ${highRelevanceResult.prediction}\n` +
    `Confidence: ${highRelevanceResult.confidence}%\n\n` +
    
    `Example 2 (Usage Guide):\n` +
    `Score: ${lowRelevanceResult.score}\n` +
    `Prediction: ${lowRelevanceResult.prediction}\n` +
    `Confidence: ${lowRelevanceResult.confidence}%`,
    ui.ButtonSet.OK
  );
  
  return { highRelevanceResult, lowRelevanceResult };
}

/**
 * Creates a UI to test article relevance
 */
function showRelevancePredictorUI() {
  const html = HtmlService.createHtmlOutput(`
    <html>
      <head>
        <base target="_top">
        <style>
          body { font-family: Arial, sans-serif; margin: 10px; }
          label { display: block; margin-top: 15px; font-weight: bold; }
          input, textarea { width: 100%; margin-top: 5px; padding: 5px; }
          button { margin-top: 20px; padding: 10px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; }
          #result { margin-top: 20px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; display: none; }
          .score-box { font-size: 24px; text-align: center; padding: 10px; margin: 10px 0; border-radius: 4px; }
          .high { background-color: #ccffcc; }
          .medium { background-color: #ffffcc; }
          .low { background-color: #ffcccc; }
          .factor { margin: 5px 0; }
          .impact-positive { color: green; }
          .impact-negative { color: red; }
        </style>
      </head>
      <body>
        <h2>AI Article Relevance Predictor</h2>
        <p>Enter an article title and content to predict its relevance score based on learned patterns.</p>
        
        <label for="title">Article Title:</label>
        <input type="text" id="title" name="title" placeholder="Enter the article title...">
        
        <label for="content">Article Content or Summary:</label>
        <textarea id="content" name="content" rows="6" placeholder="Paste article content or a summary..."></textarea>
        
        <button onclick="predictRelevance()">Predict Relevance</button>
        
        <div id="result">
          <h3>Prediction Results</h3>
          <div id="score-container" class="score-box">
            <span id="score">0.0</span>/10
          </div>
          <p><strong>Assessment:</strong> <span id="prediction"></span></p>
          <p><strong>Confidence:</strong> <span id="confidence"></span>%</p>
          
          <div id="explanation" style="margin-top: 15px;">
            <h4>Explanation</h4>
            <p><strong>Base score:</strong> 5.0 (medium relevance)</p>
            
            <div id="factors">
              <!-- Factors will be added here dynamically -->
            </div>
          </div>
        </div>
        
        <script>
          function predictRelevance() {
            const title = document.getElementById('title').value;
            const content = document.getElementById('content').value;
            
            if (!title || !content) {
              alert('Please enter both a title and content');
              return;
            }
            
            // Disable button while processing
            const button = document.querySelector('button');
            button.disabled = true;
            button.textContent = 'Analyzing...';
            
            // Call the server-side function
            google.script.run
              .withSuccessHandler(displayResults)
              .withFailureHandler(showError)
              .predictArticleRelevance(title, content, { detailed: true });
          }
          
          function displayResults(result) {
            // Re-enable button
            const button = document.querySelector('button');
            button.disabled = false;
            button.textContent = 'Predict Relevance';
            
            // Update the UI with results
            document.getElementById('score').textContent = result.score.toFixed(1);
            document.getElementById('prediction').textContent = result.prediction;
            document.getElementById('confidence').textContent = result.confidence;
            
            // Set score box color based on score
            const scoreContainer = document.getElementById('score-container');
            scoreContainer.className = 'score-box';
            if (result.score >= 8) {
              scoreContainer.classList.add('high');
            } else if (result.score >= 4) {
              scoreContainer.classList.add('medium');
            } else {
              scoreContainer.classList.add('low');
            }
            
            // Display factors if available
            const factorsContainer = document.getElementById('factors');
            factorsContainer.innerHTML = '';
            
            if (result.explanation && result.explanation.factors) {
              const factors = result.explanation.factors;
              
              // Add high relevance keywords
              if (factors.highRelevanceKeywords && factors.highRelevanceKeywords.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>High Relevance Keywords:</h5>';
                factors.highRelevanceKeywords.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = '"' + item.keyword + '" <span class="impact-positive">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add low relevance keywords
              if (factors.lowRelevanceKeywords && factors.lowRelevanceKeywords.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Low Relevance Keywords:</h5>';
                factors.lowRelevanceKeywords.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = '"' + item.keyword + '" <span class="impact-negative">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add high relevance contexts
              if (factors.highRelevanceContexts && factors.highRelevanceContexts.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>High Relevance Contexts:</h5>';
                factors.highRelevanceContexts.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = 'Pattern: "' + shortenRegex(item.context) + '" <span class="impact-positive">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add low relevance contexts
              if (factors.lowRelevanceContexts && factors.lowRelevanceContexts.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Low Relevance Contexts:</h5>';
                factors.lowRelevanceContexts.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = 'Pattern: "' + shortenRegex(item.context) + '" <span class="impact-negative">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add extracted patterns
              if (factors.extractedPatterns && factors.extractedPatterns.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Extracted Patterns:</h5>';
                factors.extractedPatterns.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  const impactClass = item.impact > 0 ? 'impact-positive' : 'impact-negative';
                  factor.innerHTML = '"' + item.pattern + '" <span class="' + impactClass + '">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
            }
            
            // Show the result section
            document.getElementById('result').style.display = 'block';
          }
          
          function showError(error) {
            // Re-enable button
            const button = document.querySelector('button');
            button.disabled = false;
            button.textContent = 'Predict Relevance';
            
            // Show error
            alert('Error: ' + error.message);
          }
          
          function shortenRegex(regexStr) {
            // Make regex strings more readable
            return regexStr
              .replace(/\\b/g, '')
              .replace(/\\s\+/g, ' ')
              .replace(/\.\{1,\d+\}/g, '...')
              .replace(/\[\.\*\+\?\^\$\{\}\(\)\|\[\]\\\\\]/g, '[special chars]')
              .replace(/\\\\\$\&/g, '$&')
              .replace(/\(.*?\|.*?\)/g, '(...)')
              .replace(/\[\^\w\+\]/g, '[...]');
          }
        </script>
      </body>
    </html>
  `)
  .setTitle('AI Article Relevance Predictor')
  .setWidth(600)
  .setHeight(700);
  
  SpreadsheetApp.getUi().showModalDialog(html, 'AI Article Relevance Predictor');
}

/**
 * Add this function to the menu
 */
function setupRelevancePredictorMenu() {
  const ui = SpreadsheetApp.getUi();
  
  // Add to Research Log menu
  const menu = ui.createMenu('Research Log')
    .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
    .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
    .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
    .addSeparator()
    .addItem('Test Relevance Predictor', 'testRelevancePrediction')
    .addItem('Open Relevance Predictor', 'showRelevancePredictorUI')
    .addSeparator()
    .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved');
  
  // Try to add to UI, if not already there
  try {
    menu.addToUi();
  } catch (e) {
    Logger.log('Menu may already exist: ' + e.message);
  }
}
/**
 * Modified sidebar display function to handle debugging
 */
function showRelevancePredictorSidebar() {
  const html = HtmlService.createHtmlOutput(`
    <html>
      <head>
        <base target="_top">
        <style>
          body { font-family: Arial, sans-serif; margin: 10px; font-size: 12px; }
          label { display: block; margin-top: 15px; font-weight: bold; }
          input, textarea { width: 100%; margin-top: 5px; padding: 5px; box-sizing: border-box; }
          button { margin-top: 15px; padding: 8px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; }
          #result { margin-top: 15px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; display: none; }
          .score-box { font-size: 20px; text-align: center; padding: 8px; margin: 8px 0; border-radius: 4px; }
          .high { background-color: #ccffcc; }
          .medium { background-color: #ffffcc; }
          .low { background-color: #ffcccc; }
          .factor { margin: 3px 0; font-size: 11px; }
          .impact-positive { color: green; }
          .impact-negative { color: red; }
          h2 { font-size: 16px; }
          h3, h4 { font-size: 14px; }
          h5 { font-size: 12px; margin: 10px 0 5px 0; }
          #loading { display: none; text-align: center; margin-top: 15px; }
          .actions { display: flex; gap: 5px; }
          #clear { background: #f1f1f1; color: #333; }
          .collapsible { cursor: pointer; padding: 5px; background: #f1f1f1; border: none; text-align: left; width: 100%; border-radius: 3px; margin-top: 10px; position: relative; }
          .collapsible:after { content: '+'; position: absolute; right: 10px; }
          .active:after { content: '-'; }
          .expandable { display: none; overflow: hidden; padding: 0 5px; }
          #debug { display: none; margin-top: 15px; padding: 5px; background: #f5f5f5; font-family: monospace; font-size: 10px; }
          #manualLoad { margin-top: 5px; background: #f1f1f1; color: #333; padding: 6px; }
        </style>
      </head>
      <body>
        <h2>AI Article Relevance Predictor</h2>
        <p>Enter an article title and content to predict its relevance score based on learned patterns.</p>
        
        <button id="manualLoad" onclick="loadFromActiveCell()">Load from Selected Row</button>
        
        <label for="title">Article Title:</label>
        <input type="text" id="title" name="title" placeholder="Enter the article title...">
        
        <label for="content">Article Content or Summary:</label>
        <textarea id="content" name="content" rows="6" placeholder="Paste article content or a summary..."></textarea>
        
        <div class="actions">
          <button id="predict" onclick="predictRelevance()">Predict Relevance</button>
          <button id="clear" onclick="clearForm()">Clear</button>
          <button id="toggleDebug" onclick="toggleDebug()" style="background: #f1f1f1; color: #333;">Debug</button>
        </div>
        
        <div id="loading">
          Analyzing article... <br>
          <img src="https://www.google.com/images/spin-32.gif" alt="Loading..." width="20" height="20">
        </div>
        
        <div id="debug"></div>
        
        <div id="result">
          <h3>Prediction Results</h3>
          <div id="score-container" class="score-box">
            <span id="score">0.0</span>/10
          </div>
          <p><strong>Assessment:</strong> <span id="prediction"></span></p>
          <p><strong>Confidence:</strong> <span id="confidence"></span>%</p>
          
          <button class="collapsible" onclick="toggleSection(this)">View Detailed Explanation</button>
          <div class="expandable">
            <div id="explanation" style="margin-top: 10px;">
              <p><strong>Base score:</strong> 5.0 (medium relevance)</p>
              
              <div id="factors">
                <!-- Factors will be added here dynamically -->
              </div>
            </div>
          </div>
        </div>
        
        <script>
          // Loads the content from current active cell if possible
          function loadFromActiveCell() {
            // Show loading status in debug
            document.getElementById('debug').style.display = 'block';
            document.getElementById('debug').innerHTML = 'Loading from active cell...';
            
            google.script.run
              .withSuccessHandler(populateFromActiveCell)
              .withFailureHandler(function(error) {
                document.getElementById('debug').innerHTML += '<br>Error: ' + error;
              })
              .getActiveRowContent();
          }
          
          function populateFromActiveCell(data) {
            const debugDiv = document.getElementById('debug');
            
            if (!data) {
              debugDiv.innerHTML += '<br>No data returned from active cell';
              return;
            }
            
            debugDiv.innerHTML += '<br>Data received: ' + JSON.stringify(data);
            
            if (data.articleTitle) {
              document.getElementById('title').value = data.articleTitle;
              debugDiv.innerHTML += '<br>Set title: ' + data.articleTitle;
            } else {
              debugDiv.innerHTML += '<br>No article title found';
            }
            
            if (data.content) {
              document.getElementById('content').value = data.content;
              debugDiv.innerHTML += '<br>Set content: ' + data.content.substring(0, 50) + '...';
              
              // If we have content, predict automatically
              predictRelevance();
            } else {
              debugDiv.innerHTML += '<br>No content found';
            }
          }
          
          function predictRelevance() {
            const title = document.getElementById('title').value;
            const content = document.getElementById('content').value;
            
            if (!title && !content) {
              alert('Please enter either a title or content');
              return;
            }
            
            // Show loading, hide result
            document.getElementById('loading').style.display = 'block';
            document.getElementById('result').style.display = 'none';
            
            // Disable button while processing
            const button = document.getElementById('predict');
            button.disabled = true;
            
            // Call the server-side function
            google.script.run
              .withSuccessHandler(displayResults)
              .withFailureHandler(showError)
              .predictArticleRelevance(title, content, { detailed: true });
          }
          
          function displayResults(result) {
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Re-enable button
            document.getElementById('predict').disabled = false;
            
            // Update the UI with results
            document.getElementById('score').textContent = result.score.toFixed(1);
            document.getElementById('prediction').textContent = result.prediction;
            document.getElementById('confidence').textContent = result.confidence;
            
            // Set score box color based on score
            const scoreContainer = document.getElementById('score-container');
            scoreContainer.className = 'score-box';
            if (result.score >= 8) {
              scoreContainer.classList.add('high');
            } else if (result.score >= 4) {
              scoreContainer.classList.add('medium');
            } else {
              scoreContainer.classList.add('low');
            }
            
            // Display factors if available
            const factorsContainer = document.getElementById('factors');
            factorsContainer.innerHTML = '';
            
            if (result.explanation && result.explanation.factors) {
              const factors = result.explanation.factors;
              
              // Add high relevance keywords
              if (factors.highRelevanceKeywords && factors.highRelevanceKeywords.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>High Relevance Keywords:</h5>';
                factors.highRelevanceKeywords.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = '"' + item.keyword + '" <span class="impact-positive">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add low relevance keywords
              if (factors.lowRelevanceKeywords && factors.lowRelevanceKeywords.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Low Relevance Keywords:</h5>';
                factors.lowRelevanceKeywords.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = '"' + item.keyword + '" <span class="impact-negative">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add high relevance contexts
              if (factors.highRelevanceContexts && factors.highRelevanceContexts.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>High Relevance Contexts:</h5>';
                factors.highRelevanceContexts.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = 'Pattern: "' + shortenRegex(item.context) + '" <span class="impact-positive">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add low relevance contexts
              if (factors.lowRelevanceContexts && factors.lowRelevanceContexts.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Low Relevance Contexts:</h5>';
                factors.lowRelevanceContexts.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  factor.innerHTML = 'Pattern: "' + shortenRegex(item.context) + '" <span class="impact-negative">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
              
              // Add extracted patterns
              if (factors.extractedPatterns && factors.extractedPatterns.length > 0) {
                const section = document.createElement('div');
                section.innerHTML = '<h5>Extracted Patterns:</h5>';
                factors.extractedPatterns.forEach(item => {
                  const factor = document.createElement('div');
                  factor.className = 'factor';
                  const impactClass = item.impact > 0 ? 'impact-positive' : 'impact-negative';
                  factor.innerHTML = '"' + item.pattern + '" <span class="' + impactClass + '">(' + item.impact + ')</span>';
                  section.appendChild(factor);
                });
                factorsContainer.appendChild(section);
              }
            }
            
            // Show the result section
            document.getElementById('result').style.display = 'block';
          }
          
          function showError(error) {
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Re-enable button
            document.getElementById('predict').disabled = false;
            
            // Show error
            alert('Error: ' + error.message);
            
            // Add to debug
            document.getElementById('debug').innerHTML += '<br>Error: ' + error;
          }
          
          function shortenRegex(regexStr) {
            // Make regex strings more readable
            return regexStr
              .replace(/\\b/g, '')
              .replace(/\\s\+/g, ' ')
              .replace(/\.\{1,\d+\}/g, '...')
              .replace(/\[\.\*\+\?\^\$\{\}\(\)\|\[\]\\\\\]/g, '[special chars]')
              .replace(/\\\\\$\&/g, '$&')
              .replace(/\(.*?\|.*?\)/g, '(...)')
              .replace(/\[\^\w\+\]/g, '[...]');
          }
          
          function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('content').value = '';
            document.getElementById('result').style.display = 'none';
          }
          
          function toggleSection(element) {
            element.classList.toggle("active");
            const content = element.nextElementSibling;
            if (content.style.display === "block") {
              content.style.display = "none";
            } else {
              content.style.display = "block";
            }
          }
          
          function toggleDebug() {
            const debugDiv = document.getElementById('debug');
            if (debugDiv.style.display === "block") {
              debugDiv.style.display = "none";
            } else {
              debugDiv.style.display = "block";
            }
          }
          
          // Try to load content when the sidebar first opens
          window.onload = function() {
            loadFromActiveCell();
          };
        </script>
      </body>
    </html>
  `)
  .setTitle('AI Article Relevance Predictor')
  .setWidth(300);
  
  SpreadsheetApp.getUi().showSidebar(html);
}

/**
 * Function to get content from the active row
 * This helps pre-populate the sidebar with the selected article
 * Updated to work better with the specific spreadsheet structure
 */
function getActiveRowContent() {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    
    // Check if we're on the Research_Log sheet
    if (sheet.getName() !== "Research_Log") {
      console.log("Not on Research_Log sheet");
      return null;
    }
    
    const activeRow = SpreadsheetApp.getActiveRange().getRow();
    if (activeRow < 2) { // Skip header row
      console.log("Header row selected");
      return null;
    }
    
    // Get all headers to locate the columns we need
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    console.log("Headers found: " + headers.join(", "));
    
    // Find relevant columns - logging the indices for debugging
    let resultsColIndex = -1;
    let articleUrlIndex = -1;
    let notesColIndex = -1;
    
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      console.log(`Checking header: "${header}" at index ${i}`);
      
      if (header === "Results") resultsColIndex = i + 1;
      if (header === "Article URL") articleUrlIndex = i + 1;
      if (header === "Notes") notesColIndex = i + 1;
    }
    
    console.log(`Column indices - Results: ${resultsColIndex}, Article URL: ${articleUrlIndex}, Notes: ${notesColIndex}`);
    
    if (resultsColIndex === -1) {
      console.log("Results column not found");
      return null;
    }
    
    // Get content from the results column
    const content = sheet.getRange(activeRow, resultsColIndex).getValue() || "";
    console.log("Content from Results column: " + content.substring(0, 50) + "...");
    
    // Try to extract article title if possible
    let articleTitle = "";
    
    // First see if there's an article mentioned in the Results
    const articleMatch = content.match(/Article: "(.*?)"/);
    if (articleMatch && articleMatch[1]) {
      articleTitle = articleMatch[1].trim();
      console.log("Article title extracted from Results: " + articleTitle);
    } 
    // Otherwise check if we have a valid Article URL
    else if (articleUrlIndex > 0) {
      const articleUrl = sheet.getRange(activeRow, articleUrlIndex).getValue() || "";
      // If it has a URL, use its text as a title
      if (articleUrl) {
        try {
          const urlObj = new URL(articleUrl);
          articleTitle = urlObj.pathname.split('/').pop() || urlObj.hostname;
          console.log("Article title from URL: " + articleTitle);
        } catch (e) {
          // Not a valid URL, just use as is
          articleTitle = articleUrl;
        }
      }
    }
    
    // Get notes if available for additional context
    let notes = "";
    if (notesColIndex > 0) {
      notes = sheet.getRange(activeRow, notesColIndex).getValue() || "";
      console.log("Notes content: " + (notes ? notes.substring(0, 50) + "..." : "None"));
    }
    
    // Combine content and notes
    const combinedContent = content + (notes ? "\n\n" + notes : "");
    
    return {
      articleTitle: articleTitle,
      content: combinedContent
    };
  } catch (error) {
    console.log("Error getting active row content: " + error.message);
    return null;
  }
}
/**
 * Update menu function to include the sidebar version
 */
function setupRelevancePredictorMenu() {
  const ui = SpreadsheetApp.getUi();
  
  // Add to Research Log menu
  const menu = ui.createMenu('Research Log')
    .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
    .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
    .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
    .addSeparator()
    .addItem('Open Relevance Predictor (Sidebar)', 'showRelevancePredictorSidebar')
    .addItem('Test Relevance Predictor', 'testRelevancePrediction')
    .addSeparator()
    .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved');
  
  // Try to add to UI, if not already there
  try {
    menu.addToUi();
  } catch (e) {
    Logger.log('Menu may already exist: ' + e.message);
  }
}
/**
 * Function to fix column alignment issues in the Research_Log sheet
 * This realigns data that was placed in the wrong columns
 */
function fixColumnAlignment() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get all data and headers
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find the column indices by header name
    const columnIndices = {
      date: headers.indexOf("Date"),
      source: headers.indexOf("Source"),
      checkDate: headers.indexOf("Checked"),
      type: headers.indexOf("Type"),
      url: headers.indexOf("URL"),
      articleUrl: headers.indexOf("Article URL"),
      results: headers.indexOf("Results"),
      notes: headers.indexOf("Notes"),
      relevanceScore: headers.indexOf("Relevance Score"),
      relevanceExplanation: headers.indexOf("Relevance Explanation"),
      learningApplied: headers.indexOf("Learning Applied")
    };
    
    // Check if we have the expected columns
    for (const [key, index] of Object.entries(columnIndices)) {
      if (index === -1) {
        console.log(`Column not found: ${key}`);
      }
    }
    
    // Verify we have the key columns we need to fix the alignment
    if (columnIndices.articleUrl === -1 || columnIndices.results === -1 || columnIndices.notes === -1) {
      throw new Error("Cannot fix alignment: One or more required columns missing");
    }
    
    // Check for misalignment: If we see data in Article URL that looks like Results,
    // and data in Results that looks like Notes
    let misalignedRows = [];
    let totalFixed = 0;
    
    // Process each row (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell)) continue;
      
      const articleUrlValue = row[columnIndices.articleUrl];
      const resultsValue = row[columnIndices.results];
      
      // Check if results data is in the article URL column
      // Typical results values contain "Potential new model found:" or similar text
      if (typeof articleUrlValue === 'string' && 
          (articleUrlValue.includes("Potential new model found:") || 
           articleUrlValue.includes("No new models found") ||
           articleUrlValue.includes("No articles found") ||
           articleUrlValue.includes("Error checking"))) {
        
        // This row is misaligned
        misalignedRows.push(i + 1); // +1 for 1-based row index
        
        // Create a backup of the row data
        const backup = [...row];
        
        // Shift data right for the affected columns
        // Shift Results to Notes, then Article URL to Results
        if (columnIndices.notes > -1) {
          sheet.getRange(i + 1, columnIndices.notes + 1).setValue(resultsValue);
        }
        sheet.getRange(i + 1, columnIndices.results + 1).setValue(articleUrlValue);
        
        // Clear the original Article URL column (now contains Results data)
        sheet.getRange(i + 1, columnIndices.articleUrl + 1).setValue("");
        
        totalFixed++;
      }
    }
    
    // Create a summary message
    let message = `Fixed column alignment for ${totalFixed} rows.`;
    if (misalignedRows.length > 0) {
      message += `\n\nRows that were fixed: ${misalignedRows.join(", ")}`;
    }
    
    // Display message
    SpreadsheetApp.getUi().alert('Column Alignment Fix', message, SpreadsheetApp.getUi().ButtonSet.OK);
    
    return totalFixed;
    
  } catch (error) {
    console.log(`Error fixing column alignment: ${error.message}`);
    SpreadsheetApp.getUi().alert('Error', `Could not fix column alignment: ${error.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
    return 0;
  }
}

/**
 * Alternative approach: Check and fix any newly added entries
 * whenever the sheet is edited
 */
function onEdit(e) {
  // Only run if we're in the Research_Log sheet
  const sheet = e.source.getActiveSheet();
  if (sheet.getName() !== "Research_Log") return;
  
  // Only run if the edit was in a range where we expect results
  const range = e.range;
  const row = range.getRow();
  const column = range.getColumn();
  
  // Skip header row
  if (row === 1) return;
  
  // Get the headers to find column indices
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Find column indices
  const articleUrlColIndex = headers.indexOf("Article URL") + 1;
  const resultsColIndex = headers.indexOf("Results") + 1;
  
  // If the edit was in the Article URL column and looks like Results data
  if (column === articleUrlColIndex) {
    const value = e.value;
    if (typeof value === 'string' && 
        (value.includes("Potential new model found:") || 
         value.includes("No new models found") ||
         value.includes("No articles found") ||
         value.includes("Error checking"))) {
      
      // This looks like results data in the Article URL column
      // Get the current value in the Results column
      const currentResults = sheet.getRange(row, resultsColIndex).getValue();
      
      // Shift the data right
      // First, move the existing Results data to the Notes column
      const notesColIndex = headers.indexOf("Notes") + 1;
      if (notesColIndex > 0) {
        sheet.getRange(row, notesColIndex).setValue(currentResults);
      }
      
      // Then move the Article URL data (which is actually Results data) to Results column
      sheet.getRange(row, resultsColIndex).setValue(value);
      
      // Clear the original cell
      sheet.getRange(row, articleUrlColIndex).setValue("");
    }
  }
}

/**
 * Add column fix to the menu
 */
function updateResearchLogMenu() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu with the new option
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addSeparator()
      .addItem('Open Relevance Predictor (Sidebar)', 'showRelevancePredictorSidebar')
      .addItem('Test Relevance Predictor', 'testRelevancePrediction')
      .addSeparator()
      .addItem('Fix Column Alignment', 'fixColumnAlignment')
      .addSeparator()
      .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved')
      .addToUi();
  } catch (e) {
    console.log('Error creating Research Log menu: ' + e.message);
  }
}

/**
 * Helper function to make both fixes to the Research_Log setup
 */
function fixResearchLogSheet() {
  // First fix the column alignment issue
  const fixedCount = fixColumnAlignment();
  
  // Then update the menu to include the fix option
  updateResearchLogMenu();
  
  return fixedCount;
}
/**
 * Enhanced Research Log Processing
 * This set of functions improves the Research Log system by:
 * 1. Detecting and handling duplicate entries
 * 2. Ensuring all rows are properly processed for relevance learning
 */

/**
 * Process the Research Log to detect and mark duplicates
 * Also ensures all rows have been properly evaluated for relevance
 */
function enhanceResearchLog() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get all data and headers
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const columnIndices = {
      date: headers.indexOf("Date"),
      url: headers.indexOf("URL"),
      articleUrl: headers.indexOf("Article URL"),
      results: headers.indexOf("Results"),
      notes: headers.indexOf("Notes"),
      relevanceScore: headers.indexOf("Relevance Score"),
      relevanceExplanation: headers.indexOf("Relevance Explanation"),
      learningApplied: headers.indexOf("Learning Applied")
    };
    
    // Check if we have the expected columns
    const missingColumns = [];
    for (const [key, index] of Object.entries(columnIndices)) {
      if (index === -1) {
        missingColumns.push(key);
      }
    }
    
    if (missingColumns.length > 0) {
      throw new Error(`Missing columns: ${missingColumns.join(", ")}`);
    }
    
    // Create a predicted relevance column if it doesn't exist
    let predictedRelevanceIndex = headers.indexOf("Predicted Relevance");
    if (predictedRelevanceIndex === -1) {
      const newCol = sheet.getLastColumn() + 1;
      sheet.getRange(1, newCol).setValue("Predicted Relevance");
      predictedRelevanceIndex = headers.length;
      headers.push("Predicted Relevance");
      
      // Add the new column to all rows in our data array
      for (let i = 1; i < data.length; i++) {
        data[i][predictedRelevanceIndex] = "";
      }
    }
    
    // Track URLs and content to identify duplicates
    const processedUrls = {};
    const processedTitles = {};
    const processedContent = {};
    let duplicatesFound = 0;
    let missingRelevanceScores = 0;
    
    // Also track which rows need relevance prediction
    const rowsNeedingPrediction = [];
    
    // Process each row (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell)) continue;
      
      const rowUrl = row[columnIndices.url] || "";
      const articleUrl = row[columnIndices.articleUrl] || "";
      const results = row[columnIndices.results] || "";
      const relevanceScore = row[columnIndices.relevanceScore];
      const learningApplied = row[columnIndices.learningApplied] || "";
      const predictedRelevance = row[predictedRelevanceIndex];
      
      // Extract article title if present
      let articleTitle = "";
      const articleMatch = results.toString().match(/Article: "(.*?)"/);
      if (articleMatch && articleMatch[1]) {
        articleTitle = articleMatch[1].trim();
      }
      
      // Check for duplicates by URL
      if (rowUrl) {
        if (processedUrls[rowUrl]) {
          // This is a duplicate URL
          const originalRow = processedUrls[rowUrl];
          
          // Mark in the notes column that this is a duplicate
          const currentNotes = row[columnIndices.notes] || "";
          if (!currentNotes.includes("DUPLICATE")) {
            const newNote = currentNotes ? 
              currentNotes + " [URL DUPLICATE of row " + originalRow + "]" : 
              "[URL DUPLICATE of row " + originalRow + "]";
            
            sheet.getRange(i + 1, columnIndices.notes + 1).setValue(newNote);
            duplicatesFound++;
            
            // Skip further checks for this row
            continue;
          }
        } else {
          // Record this URL as processed
          processedUrls[rowUrl] = i + 1; // Store 1-based row number
        }
      }
      
      // Check for duplicates by article title
      if (articleTitle) {
        const titleKey = articleTitle.toLowerCase();
        if (processedTitles[titleKey]) {
          // This is a duplicate title
          const originalRow = processedTitles[titleKey];
          
          // Mark in the notes column that this is a duplicate
          const currentNotes = row[columnIndices.notes] || "";
          if (!currentNotes.includes("DUPLICATE")) {
            const newNote = currentNotes ? 
              currentNotes + " [TITLE DUPLICATE of row " + originalRow + "]" : 
              "[TITLE DUPLICATE of row " + originalRow + "]";
            
            sheet.getRange(i + 1, columnIndices.notes + 1).setValue(newNote);
            duplicatesFound++;
            
            // Skip further checks for this row
            continue;
          }
        } else {
          // Record this title as processed
          processedTitles[titleKey] = i + 1;
        }
      }
      
      // Only check content if we don't have a matching URL or title
      if (results && !articleTitle) {
        // Create a simplified content signature for comparison
        const contentSignature = results
          .replace(/\s+/g, ' ')
          .toLowerCase()
          .trim();
        
        if (contentSignature.length > 20) { // Only check substantial content
          if (processedContent[contentSignature]) {
            // This is duplicate content
            const originalRow = processedContent[contentSignature];
            
            // Mark in the notes column that this is a duplicate
            const currentNotes = row[columnIndices.notes] || "";
            if (!currentNotes.includes("DUPLICATE")) {
              const newNote = currentNotes ? 
                currentNotes + " [CONTENT DUPLICATE of row " + originalRow + "]" : 
                "[CONTENT DUPLICATE of row " + originalRow + "]";
              
              sheet.getRange(i + 1, columnIndices.notes + 1).setValue(newNote);
              duplicatesFound++;
              
              // Skip further checks for this row
              continue;
            }
          } else {
            // Record this content as processed
            processedContent[contentSignature] = i + 1;
          }
        }
      }
      
      // If we got here, this entry is not a duplicate
      
      // Check if this row needs a relevance score or prediction
      if (results && !relevanceScore && isNaN(relevanceScore)) {
        // Missing relevance score - this row hasn't been evaluated yet
        try {
          // Apply initial relevance assessment
          prepareNewResearchLogEntry(i + 1);
          missingRelevanceScores++;
        } catch (e) {
          console.log(`Error preparing entry at row ${i + 1}: ${e.message}`);
        }
      }
      
      // Check if this row needs a predicted relevance score
      if (results && !predictedRelevance && isNaN(predictedRelevance)) {
        rowsNeedingPrediction.push(i + 1); // 1-based row number
      }
      
      // Check if learning has been applied to rows with relevance scores
      if (relevanceScore && !isNaN(relevanceScore) && !learningApplied) {
        // This row has a relevance score but learning hasn't been applied
        // Mark for learning in the next pass
        sheet.getRange(i + 1, columnIndices.learningApplied + 1).setValue("Pending");
      }
    }
    
    // Generate predicted relevance scores for rows that need them
    let predictionsGenerated = 0;
    if (rowsNeedingPrediction.length > 0) {
      try {
        predictionsGenerated = generatePredictedRelevanceScores(rowsNeedingPrediction, predictedRelevanceIndex);
      } catch (e) {
        console.log(`Error generating predictions: ${e.message}`);
      }
    }
    
    // Apply relevance learning to all rows that have been marked with scores
    const learningResult = {rowsProcessed: 0, patternsFound: 0};
    try {
      const result = applyRelevanceLearningToAllRows();
      if (result && !result.error) {
        Object.assign(learningResult, result);
      }
    } catch (e) {
      console.log(`Error applying relevance learning: ${e.message}`);
    }
    
    // Create a summary message
    let message = `Research Log Enhancement Complete\n\n`;
    message += `${duplicatesFound} duplicates identified and marked\n`;
    message += `${missingRelevanceScores} rows had missing relevance scores and were updated\n`;
    message += `${predictionsGenerated} predicted relevance scores were generated\n`;
    message += `${learningResult.rowsProcessed} rows processed for relevance learning\n`;
    message += `${learningResult.patternsFound} relevance patterns identified`;
    
    // Display message
    SpreadsheetApp.getUi().alert('Research Log Enhanced', message, SpreadsheetApp.getUi().ButtonSet.OK);
    
    return {
      duplicatesFound,
      missingRelevanceScores,
      predictionsGenerated,
      learningResult
    };
    
  } catch (error) {
    console.log(`Error enhancing Research Log: ${error.message}`);
    SpreadsheetApp.getUi().alert('Error', `Error enhancing Research Log: ${error.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
    return {
      error: error.message
    };
  }
}

/**
 * Generate predicted relevance scores for specified rows
 * @param {Array} rowNumbers - Array of row numbers to process
 * @param {number} predictedColIndex - Column index for predicted relevance
 * @return {number} - Number of predictions generated
 */
function generatePredictedRelevanceScores(rowNumbers, predictedColIndex) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Research_Log");
    if (!sheet) return 0;
    
    let generatedCount = 0;
    
    // Get the headers to find relevant columns
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Find column indices
    const resultsColIndex = headers.indexOf("Results");
    const notesColIndex = headers.indexOf("Notes");
    
    if (resultsColIndex === -1) return 0;
    
    // Process each row
    for (const rowNumber of rowNumbers) {
      try {
        // Get the results and notes content
        const results = sheet.getRange(rowNumber, resultsColIndex + 1).getValue() || "";
        const notes = notesColIndex !== -1 ? sheet.getRange(rowNumber, notesColIndex + 1).getValue() || "" : "";
        
        // Skip if no results
        if (!results) continue;
        
        // Extract any title information from results
        let title = "";
        const articleMatch = results.match(/Article: "(.*?)"/);
        if (articleMatch && articleMatch[1]) {
          title = articleMatch[1].trim();
        }
        
        // Combine title and content for prediction
        const combined = title ? `${title}. ${results} ${notes}` : `${results} ${notes}`;
        
        // Use the prediction function to get a score
        const prediction = predictArticleRelevance(title, combined);
        
        // Write the prediction to the cell
        sheet.getRange(rowNumber, predictedColIndex + 1).setValue(prediction.score);
        
        generatedCount++;
      } catch (rowError) {
        console.log(`Error generating prediction for row ${rowNumber}: ${rowError.message}`);
        continue;
      }
    }
    
    return generatedCount;
  } catch (error) {
    console.log(`Error generating predictions: ${error.message}`);
    return 0;
  }
}

/**
 * Apply relevance learning to all rows in the Research_Log
 * This is an enhanced version that ensures all rows are processed
 */
function applyRelevanceLearningToAllRows() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get column indices
    const columns = setupResearchLogRelevanceTracking();
    if (!columns) {
      throw new Error("Failed to set up relevance tracking columns");
    }
    
    // Get all data
    const data = sheet.getDataRange().getValues();
    const headerRow = data[0];
    
    // Map column names to indices
    const columnMap = {};
    headerRow.forEach((header, index) => {
      columnMap[header] = index;
    });
    
    // Check for required columns using the column map
    const resultsColIndex = columnMap["Results"];
    const relevanceColIndex = columns.relevanceColIndex - 1; // Convert to 0-based index
    const explanationColIndex = columns.explanationColIndex - 1;
    const learningColIndex = columns.learningColIndex - 1;
    
    if (resultsColIndex === undefined) {
      throw new Error("Required column 'Results' not found in Research_Log");
    }
    
    // Statistics tracking
    const keywordStats = {
      highRelevance: {}, // Keywords that appear in high relevance entries
      lowRelevance: {},  // Keywords that appear in low relevance entries
      patterns: []       // Patterns identified from explanations
    };
    
    let rowsProcessed = 0;
    
    // Process each row (skip header)
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell)) continue;
      
      const relevanceScore = row[relevanceColIndex] ? Number(row[relevanceColIndex]) : null;
      const explanation = row[explanationColIndex] || "";
      const learningApplied = row[learningColIndex] || "";
      
      // Only process rows with relevance scores that haven't had learning applied yet
      // or are marked as "Pending"
      if (relevanceScore === null || 
          (learningApplied !== "" && learningApplied !== "Pending")) {
        continue;
      }
      
      // Get content from Results column
      const content = row[resultsColIndex] || "";
      
      // Also check Notes column if it exists
      const notesColIndex = columnMap["Notes"];
      const notes = notesColIndex !== undefined ? row[notesColIndex] || "" : "";
      
      // Combine content from Results and Notes for better keyword extraction
      const combinedContent = content + " " + notes;
      
      // Extract potential keywords from content
      const keywordList = extractKeywordsFromContent(combinedContent);
      
      // Categorize by relevance
      const relevanceCategory = relevanceScore >= 8 ? "highRelevance" : 
                              relevanceScore <= 3 ? "lowRelevance" : null;
      
      if (relevanceCategory && keywordList.length > 0) {
        for (const keyword of keywordList) {
          if (!keywordStats[relevanceCategory][keyword]) {
            keywordStats[relevanceCategory][keyword] = 0;
          }
          keywordStats[relevanceCategory][keyword]++;
        }
      }
      
      // Extract potential model names from "Article" mentions in the content
      const articleMatches = content.match(/Article: "([^"]+)"/);
      if (articleMatches && articleMatches[1]) {
        const articleTitle = articleMatches[1].trim();
        // Add the article title as a potential keyword
        if (relevanceCategory) {
          if (!keywordStats[relevanceCategory][articleTitle]) {
            keywordStats[relevanceCategory][articleTitle] = 0;
          }
          keywordStats[relevanceCategory][articleTitle]++;
        }
      }
      
      // Extract patterns from explanations
      if (explanation) {
        // Look for patterns in the explanation
        const patternMatches = [
          ...explanation.matchAll(/(?:because|due to|contains?)\s+["']([^"']+)["']/gi),
          ...explanation.matchAll(/mentions?\s+["']([^"']+)["']/gi),
          ...explanation.matchAll(/(?:high|low)\s+relevance\s+(?:due to|because of)\s+["']([^"']+)["']/gi)
        ];
        
        for (const match of patternMatches) {
          if (match[1]) {
            keywordStats.patterns.push({
              pattern: match[1].trim(),
              relevanceScore: relevanceScore,
              explanation: explanation
            });
          }
        }
      }
      
      // Mark this row as having learning applied
      sheet.getRange(i+1, columns.learningColIndex).setValue("Applied");
      rowsProcessed++;
    }
    
    // Process the collected statistics
    let report = "Relevance Learning Analysis:\n\n";
    
    // Find keywords that are consistently in high-relevance entries
    const highRelevanceKeywords = Object.entries(keywordStats.highRelevance)
      .filter(([_, count]) => count >= 2)  // Appear in at least 2 high-relevance entries
      .sort((a, b) => b[1] - a[1]);        // Sort by frequency
    
    // Find keywords that are consistently in low-relevance entries
    const lowRelevanceKeywords = Object.entries(keywordStats.lowRelevance)
      .filter(([_, count]) => count >= 3)  // Appear in at least 3 low-relevance entries
      .sort((a, b) => b[1] - a[1]);        // Sort by frequency
    
    // Generate report for high-relevance keywords
    if (highRelevanceKeywords.length > 0) {
      report += "High-Relevance Keywords:\n";
      for (const [keyword, count] of highRelevanceKeywords) {
        report += `  - "${keyword}" (Found in ${count} high-relevance entries)\n`;
      }
      report += "\n";
    }
    
    // Generate report for low-relevance keywords
    if (lowRelevanceKeywords.length > 0) {
      report += "Low-Relevance Keywords (Consider refining these):\n";
      for (const [keyword, count] of lowRelevanceKeywords) {
        report += `  - "${keyword}" (Found in ${count} low-relevance entries)\n`;
        
        // Try to find a better version of this keyword based on patterns
        const potentialImprovements = keywordStats.patterns
          .filter(p => p.relevanceScore >= 8 && p.pattern.includes(keyword))
          .map(p => p.pattern);
        
        if (potentialImprovements.length > 0) {
          report += `      Consider replacing with more specific patterns like: ${potentialImprovements.join(", ")}\n`;
        }
      }
      report += "\n";
    }
    
    // Analyze explanations for actionable patterns
    if (keywordStats.patterns.length > 0) {
      report += "Patterns Extracted from Explanations:\n";
      
      // Group by relevance range
      const highPatterns = keywordStats.patterns.filter(p => p.relevanceScore >= 8);
      const lowPatterns = keywordStats.patterns.filter(p => p.relevanceScore <= 3);
      
      if (highPatterns.length > 0) {
        report += "  Patterns in High-Relevance Entries:\n";
        for (const pattern of highPatterns.slice(0, 5)) { // Limit to top 5
          report += `    - "${pattern.pattern}" (Score: ${pattern.relevanceScore})\n`;
        }
      }
      
      if (lowPatterns.length > 0) {
        report += "  Patterns in Low-Relevance Entries (consider excluding):\n";
        for (const pattern of lowPatterns.slice(0, 5)) { // Limit to top 5
          report += `    - "${pattern.pattern}" (Score: ${pattern.relevanceScore})\n`;
        }
      }
    }
    
    // Create a summary sheet with detailed findings
    const summarySheet = ss.getSheetByName("Relevance_Learning") || ss.insertSheet("Relevance_Learning");
    summarySheet.clear();
    
    // Add summary headers
    summarySheet.getRange(1, 1, 1, 3).setValues([["Keyword/Pattern", "Relevance Category", "Frequency/Score"]]);
    summarySheet.getRange(1, 1, 1, 3).setFontWeight("bold");
    
    // Add high relevance keywords
    let rowIndex = 2;
    for (const [keyword, count] of highRelevanceKeywords) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([[keyword, "High Relevance", count]]);
      summarySheet.getRange(rowIndex, 2).setBackground("#ccffcc"); // Green
      rowIndex++;
    }
    
    // Add low relevance keywords
    for (const [keyword, count] of lowRelevanceKeywords) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([[keyword, "Low Relevance", count]]);
      summarySheet.getRange(rowIndex, 2).setBackground("#ffcccc"); // Red
      rowIndex++;
    }
    
    // Add some space
    rowIndex += 2;
    
    // Add pattern headers
    summarySheet.getRange(rowIndex, 1, 1, 3).setValues([["Extracted Pattern", "Relevance Score", "Explanation"]]);
    summarySheet.getRange(rowIndex, 1, 1, 3).setFontWeight("bold");
    rowIndex++;
    
    // Add patterns
    for (const pattern of keywordStats.patterns) {
      summarySheet.getRange(rowIndex, 1, 1, 3).setValues([
        [pattern.pattern, pattern.relevanceScore, pattern.explanation]
      ]);
      
      // Color based on relevance
      if (pattern.relevanceScore >= 8) {
        summarySheet.getRange(rowIndex, 2).setBackground("#ccffcc"); // Green
      } else if (pattern.relevanceScore <= 3) {
        summarySheet.getRange(rowIndex, 2).setBackground("#ffcccc"); // Red
      } else {
        summarySheet.getRange(rowIndex, 2).setBackground("#ffffcc"); // Yellow
      }
      
      rowIndex++;
    }
    
    // Autosize columns
    summarySheet.autoResizeColumns(1, 3);
    
    // Create filter
    try {
      const filter = summarySheet.getFilter();
      if (filter) {
        filter.remove();
      }
      summarySheet.getRange(1, 1, rowIndex - 1, 3).createFilter();
    } catch (e) {
      console.log("Could not create filter, but analysis was completed successfully");
    }
    
    // Return stats instead of displaying UI alert (this function is called by the enhanceResearchLog function)
    return {
      rowsProcessed: rowsProcessed,
      highRelevanceKeywords: highRelevanceKeywords.length,
      lowRelevanceKeywords: lowRelevanceKeywords.length,
      patternsFound: keywordStats.patterns.length,
      report: report
    };
    
  } catch (error) {
    console.log(`Error applying relevance learning to all rows: ${error.message}`);
    return {
      error: error.message,
      rowsProcessed: 0,
      patternsFound: 0
    };
  }
}

/**
 * Add the enhancement function to the Research Log menu
 */
function updateResearchLogMenuWithEnhancements() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu with enhanced options
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addSeparator()
      .addItem('Enhance Research Log (All-in-One)', 'enhanceResearchLog')
      .addSeparator()
      .addItem('Open Relevance Predictor (Sidebar)', 'showRelevancePredictorSidebar')
      .addItem('Test Relevance Predictor', 'testRelevancePrediction')
      .addSeparator()
      .addItem('Fix Column Alignment', 'fixColumnAlignment')
      .addSeparator()
      .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved')
      .addToUi();
  } catch (e) {
    console.log('Error creating Research Log menu: ' + e.message);
  }
}
/**
 * Research Log Topic Clustering System
 * 
 * This system identifies and groups related announcements in the Research Log.
 * It uses content analysis to determine when different entries are discussing
 * the same topic, model, or capability.
 */

/**
 * Main function to cluster Research Log entries by topic
 */
function clusterResearchLogByTopic() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get all data and headers
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const columnIndices = {
      date: headers.indexOf("Date"),
      url: headers.indexOf("URL"),
      articleUrl: headers.indexOf("Article URL"),
      results: headers.indexOf("Results"),
      notes: headers.indexOf("Notes"),
      relevanceScore: headers.indexOf("Relevance Score"),
      topicCluster: headers.indexOf("Topic Cluster")
    };
    
    // Check if we have the main required columns
    if (columnIndices.results === -1) {
      throw new Error("Results column not found");
    }
    
    // Create a Topic Cluster column if it doesn't exist
    if (columnIndices.topicCluster === -1) {
      // Add the column after Notes or Relevance Score
      const insertAfterCol = columnIndices.relevanceScore !== -1 ? 
                           columnIndices.relevanceScore + 1 : 
                           (columnIndices.notes !== -1 ? 
                            columnIndices.notes + 1 : sheet.getLastColumn());
      
      sheet.insertColumnAfter(insertAfterCol);
      sheet.getRange(1, insertAfterCol + 1).setValue("Topic Cluster");
      
      // Update our indices
      columnIndices.topicCluster = insertAfterCol;
    }
    
    // Collect all entries that should be analyzed
    // Skip duplicates already identified
    const entriesToAnalyze = [];
    const skipRows = new Set(); // Rows to skip (duplicates)
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell)) continue;
      
      const notes = columnIndices.notes !== -1 ? row[columnIndices.notes] || "" : "";
      
      // Skip if this is marked as a duplicate
      if (notes.includes("DUPLICATE of row")) {
        skipRows.add(i + 1); // 1-based row number
        continue;
      }
      
      const results = row[columnIndices.results] || "";
      
      // Skip if no results content
      if (!results) continue;
      
      // Extract model mentions and article title
      let modelMentions = extractModelMentions(results);
      let articleTitle = extractArticleTitle(results);
      
      entriesToAnalyze.push({
        rowIndex: i + 1, // 1-based row number
        results: results,
        notes: notes,
        articleTitle: articleTitle,
        modelMentions: modelMentions,
        content: results + " " + notes
      });
    }
    
    // Analyze and cluster the entries
    const clusters = performTopicClustering(entriesToAnalyze);
    
    // Apply clusters to the spreadsheet
    let clusterCount = 0;
    let rowsUpdated = 0;
    
    for (const [clusterId, entries] of Object.entries(clusters)) {
      if (entries.length > 1) { // Only consider actual clusters (more than 1 entry)
        clusterCount++;
        const clusterLabel = generateClusterLabel(clusterId, entries);
        
        // Update each entry in this cluster
        for (const entry of entries) {
          sheet.getRange(entry.rowIndex, columnIndices.topicCluster + 1).setValue(clusterLabel);
          rowsUpdated++;
        }
      }
    }
    
    // Create a summary of the clusters
    createClusterSummarySheet(clusters);
    
    // Display a summary message
    const unclustered = entriesToAnalyze.length - rowsUpdated;
    const message = `Topic Clustering Complete\n\n` +
                    `Found ${clusterCount} topic clusters\n` +
                    `${rowsUpdated} entries were assigned to clusters\n` +
                    `${unclustered} entries remain as individual topics\n` +
                    `${skipRows.size} duplicate entries were skipped\n\n` +
                    `A summary sheet "Topic_Clusters" has been created with details.`;
    
    SpreadsheetApp.getUi().alert('Research Log Clustering', message, SpreadsheetApp.getUi().ButtonSet.OK);
    
    return {
      clusterCount,
      rowsUpdated,
      unclustered,
      duplicatesSkipped: skipRows.size
    };
    
  } catch (error) {
    console.log(`Error clustering Research Log: ${error.message}`);
    SpreadsheetApp.getUi().alert('Error', `Error clustering Research Log: ${error.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
    return {
      error: error.message
    };
  }
}

/**
 * Extract model mentions from the results text
 * @param {string} text - The text to analyze
 * @return {Array} - Array of model names found
 */
function extractModelMentions(text) {
  const models = [];
  
  // List of models to look for
  const modelPatterns = [
    /\bGPT-?[34](?:\.[05])?(?:-\d+[kK])?(?:\s+(?:Turbo|Vision))?/gi, // GPT-3, GPT-4, GPT-4.5, GPT-4-32k, GPT-4 Turbo
    /\bClaude(?:\s+[23](?:\.[05])?)?(?:\s+(?:Opus|Sonnet|Haiku))?/gi, // Claude, Claude 2, Claude 3, Claude 3.5, Claude Opus
    /\bGemini(?:\s+(?:Pro|Ultra|Nano|1\.5))?/gi, // Gemini, Gemini Pro, Gemini Ultra, Gemini 1.5
    /\bLlama(?:\s+[23])?(?:-\d+[bB])?/gi, // Llama, Llama 2, Llama 3, Llama-13b
    /\bMistral(?:\s+(?:Large|Medium|Small|7B|8x7B))?/gi, // Mistral, Mistral Large, Mistral 7B
    /\bMixtral(?:\s+8x7B)?/gi, // Mixtral, Mixtral 8x7B
    /\bPaLM(?:\s+[23])?/gi, // PaLM, PaLM 2
    /\bDALL-?E(?:\s+[23])?/gi, // DALL-E, DALL-E 2, DALL-E 3
    /\bSora\b/gi, // Sora
    /\bPhi(?:-[23])?/gi, // Phi, Phi-2, Phi-3
    /\bDevin\b/gi, // Devin
    /\bGrok(?:\s+\d(?:\.\d)?)?/gi // Grok, Grok 1, Grok 1.5
  ];
  
  for (const pattern of modelPatterns) {
    const matches = text.match(pattern);
    if (matches) {
      for (const match of matches) {
        // Normalize model names (remove leading/trailing spaces, convert to consistent capitalization)
        const normalizedModel = normalizeModelName(match);
        if (!models.includes(normalizedModel)) {
          models.push(normalizedModel);
        }
      }
    }
  }
  
  // Also look for explicit mentions in common patterns
  const modelFoundPattern = /(?:found|announces|releases|introduces):\s*([\w\s\.-]+)(?:\s+from\s+([\w\s]+))?/gi;
  let match;
  while ((match = modelFoundPattern.exec(text)) !== null) {
    if (match[1]) {
      const modelName = match[1].trim();
      const normalizedModel = normalizeModelName(modelName);
      if (!models.includes(normalizedModel)) {
        models.push(normalizedModel);
      }
    }
  }
  
  return models;
}

/**
 * Normalize model names to consistent format
 */
function normalizeModelName(name) {
  let normalized = name.trim();
  
  // Fix common capitalization issues
  normalized = normalized
    .replace(/\bgpt/i, 'GPT')
    .replace(/\bclaude/i, 'Claude')
    .replace(/\bgemini/i, 'Gemini')
    .replace(/\bllama/i, 'Llama')
    .replace(/\bmistral/i, 'Mistral')
    .replace(/\bmixtral/i, 'Mixtral')
    .replace(/\bpalm/i, 'PaLM')
    .replace(/\bdall-?e/i, 'DALL-E')
    .replace(/\bsora/i, 'Sora')
    .replace(/\bphi/i, 'Phi')
    .replace(/\bdevin/i, 'Devin')
    .replace(/\bgrok/i, 'Grok');
  
  return normalized;
}

/**
 * Extract the article title from results text
 */
function extractArticleTitle(text) {
  const articleMatch = text.match(/Article:\s*"([^"]+)"/);
  return articleMatch ? articleMatch[1].trim() : "";
}

/**
 * Create similarity scoring between entries
 * @param {Array} entries - The entries to analyze
 * @return {Object} - Map of cluster IDs to arrays of entries
 */
function performTopicClustering(entries) {
  // Initialize clusters
  const clusters = {};
  let nextClusterId = 1;
  
  // Group by model mentions first
  const modelGroups = {};
  
  for (const entry of entries) {
    if (entry.modelMentions.length > 0) {
      // Sort model mentions to ensure consistent key generation
      const modelKey = entry.modelMentions.sort().join('|');
      
      if (!modelGroups[modelKey]) {
        modelGroups[modelKey] = [];
      }
      modelGroups[modelKey].push(entry);
    }
  }
  
  // Process each model group for more specific clustering
  for (const [modelKey, modelEntries] of Object.entries(modelGroups)) {
    // If there's only one entry with this model combination, it's already a cluster
    if (modelEntries.length === 1) {
      const clusterId = `single_${nextClusterId++}`;
      clusters[clusterId] = modelEntries;
      continue;
    }
    
    // For multiple entries with the same models, check for topic similarity
    const topicGroups = clusterByTopicSimilarity(modelEntries);
    
    // Add each topic group as a cluster
    for (const topicGroup of topicGroups) {
      const clusterId = `cluster_${nextClusterId++}`;
      clusters[clusterId] = topicGroup;
    }
  }
  
  // Handle entries without model mentions
  const unmodeled = entries.filter(entry => entry.modelMentions.length === 0);
  
  if (unmodeled.length > 0) {
    const noModelGroups = clusterByTopicSimilarity(unmodeled);
    
    for (const group of noModelGroups) {
      const clusterId = `nomodel_${nextClusterId++}`;
      clusters[clusterId] = group;
    }
  }
  
  return clusters;
}

/**
 * Cluster entries by topic similarity (beyond just model names)
 * @param {Array} entries - Entries to cluster
 * @return {Array} - Array of clusters (each cluster is an array of entries)
 */
function clusterByTopicSimilarity(entries) {
  // If only one entry, return it as its own cluster
  if (entries.length <= 1) {
    return [entries];
  }
  
  // Initialize a similarity matrix
  const similarities = [];
  for (let i = 0; i < entries.length; i++) {
    similarities[i] = [];
    for (let j = 0; j < entries.length; j++) {
      if (i === j) {
        similarities[i][j] = 1; // Same entry = perfect similarity
      } else {
        similarities[i][j] = calculateContentSimilarity(entries[i], entries[j]);
      }
    }
  }
  
  // Use a simple agglomerative clustering approach
  // Start with each entry in its own cluster
  let currentClusters = entries.map((entry, index) => ({
    entries: [entry],
    indices: [index]
  }));
  
  // Repeatedly merge the most similar clusters until we reach a similarity threshold
  const similarityThreshold = 0.3; // Minimum similarity to consider merging
  
  while (currentClusters.length > 1) {
    // Find the most similar pair of clusters
    let maxSimilarity = 0;
    let mergeI = -1;
    let mergeJ = -1;
    
    for (let i = 0; i < currentClusters.length; i++) {
      for (let j = i + 1; j < currentClusters.length; j++) {
        // Calculate average similarity between all pairs of entries in clusters i and j
        let totalSimilarity = 0;
        let pairCount = 0;
        
        for (const indexI of currentClusters[i].indices) {
          for (const indexJ of currentClusters[j].indices) {
            totalSimilarity += similarities[indexI][indexJ];
            pairCount++;
          }
        }
        
        const avgSimilarity = totalSimilarity / pairCount;
        
        if (avgSimilarity > maxSimilarity) {
          maxSimilarity = avgSimilarity;
          mergeI = i;
          mergeJ = j;
        }
      }
    }
    
    // If max similarity is below threshold, stop merging
    if (maxSimilarity < similarityThreshold) {
      break;
    }
    
    // Merge the most similar clusters
    currentClusters[mergeI].entries = [...currentClusters[mergeI].entries, ...currentClusters[mergeJ].entries];
    currentClusters[mergeI].indices = [...currentClusters[mergeI].indices, ...currentClusters[mergeJ].indices];
    currentClusters.splice(mergeJ, 1); // Remove the merged cluster
  }
  
  // Return just the entries arrays from the clusters
  return currentClusters.map(cluster => cluster.entries);
}

/**
 * Calculate content similarity between two entries
 * @param {Object} entry1 - First entry
 * @param {Object} entry2 - Second entry
 * @return {number} - Similarity score (0-1)
 */
function calculateContentSimilarity(entry1, entry2) {
  // If they have exact same article title and it's not empty, they're very similar
  if (entry1.articleTitle && entry1.articleTitle === entry2.articleTitle) {
    return 0.9;
  }
  
  // Check title similarity if both have titles
  let titleSimilarity = 0;
  if (entry1.articleTitle && entry2.articleTitle) {
    titleSimilarity = calculateTextSimilarity(entry1.articleTitle, entry2.articleTitle);
    // If titles are very similar, they're likely the same topic
    if (titleSimilarity > 0.7) {
      return 0.8;
    }
  }
  
  // Look for specific capability or feature mentions
  const capabilities1 = extractCapabilityMentions(entry1.content);
  const capabilities2 = extractCapabilityMentions(entry2.content);
  
  // Calculate capability overlap
  let capabilityOverlap = 0;
  if (capabilities1.length > 0 && capabilities2.length > 0) {
    const common = capabilities1.filter(cap => capabilities2.includes(cap)).length;
    capabilityOverlap = (2 * common) / (capabilities1.length + capabilities2.length);
  }
  
  // Check for action similarity (what is happening with the model)
  const actions1 = extractActionMentions(entry1.content);
  const actions2 = extractActionMentions(entry2.content);
  
  let actionOverlap = 0;
  if (actions1.length > 0 && actions2.length > 0) {
    const common = actions1.filter(act => actions2.includes(act)).length;
    actionOverlap = (2 * common) / (actions1.length + actions2.length);
  }
  
  // Combine all similarity factors with weights
  const overallSimilarity = (
    titleSimilarity * 0.3 +
    capabilityOverlap * 0.4 +
    actionOverlap * 0.3
  );
  
  return overallSimilarity;
}

/**
 * Calculate text similarity between two strings
 * Uses a simple word overlap approach
 */
function calculateTextSimilarity(text1, text2) {
  const words1 = tokenizeText(text1);
  const words2 = tokenizeText(text2);
  
  if (words1.length === 0 || words2.length === 0) {
    return 0;
  }
  
  // Count common words
  const common = words1.filter(word => words2.includes(word)).length;
  
  // Jaccard similarity (size of intersection / size of union)
  const union = new Set([...words1, ...words2]).size;
  return common / union;
}

/**
 * Tokenize text into meaningful words
 */
function tokenizeText(text) {
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
    .split(/\s+/) // Split on whitespace
    .filter(word => word.length > 3) // Only keep words with 4+ chars
    .filter(word => !isStopWord(word)); // Remove common stop words
}

/**
 * Check if a word is a common stop word
 */
function isStopWord(word) {
  const stopWords = [
    'the', 'and', 'that', 'have', 'for', 'not', 'with', 'this', 'but', 'from',
    'they', 'what', 'their', 'your', 'been', 'about', 'would', 'which'
  ];
  return stopWords.includes(word);
}

/**
 * Extract capability mentions from text
 */
function extractCapabilityMentions(text) {
  const capabilities = [];
  
  const capabilityPatterns = [
    /multimodal/i,
    /vision/i,
    /image(?:\s+generation)?/i,
    /code(?:\s+generation)?/i,
    /reasoning/i,
    /agentic/i,
    /real-?time/i,
    /streaming/i,
    /fine-?tuning/i,
    /enterprise/i,
    /embedding/i,
    /function\s+calling/i,
    /on-?device/i,
    /open-?source/i,
    /chat/i,
    /video(?:\s+generation)?/i,
    /text-?to-?speech/i,
    /speech-?to-?text/i,
    /voice/i,
    /rollout/i,
    /access/i
  ];
  
  for (const pattern of capabilityPatterns) {
    if (pattern.test(text)) {
      // Extract the actual matched text
      const match = text.match(pattern);
      if (match && match[0]) {
        capabilities.push(match[0].toLowerCase());
      }
    }
  }
  
  return capabilities;
}

/**
 * Extract action mentions from text (what's happening with the model)
 */
function extractActionMentions(text) {
  const actions = [];
  
  const actionPatterns = [
    /(?:new|announced|released|launched|unveiled)/i,
    /(?:update|upgraded|improved)/i,
    /(?:expanding access|wider access|general availability)/i,
    /(?:preview|alpha|beta)/i,
    /(?:pricing|cost)/i,
    /(?:free tier|free access)/i,
    /(?:integration|integrated with)/i,
    /(?:partnership|partnered with)/i,
    /(?:discontinued|shutting down|ending)/i,
    /(?:replacing|replaced by)/i
  ];
  
  for (const pattern of actionPatterns) {
    if (pattern.test(text)) {
      // Extract the actual matched text
      const match = text.match(pattern);
      if (match && match[0]) {
        actions.push(match[0].toLowerCase());
      }
    }
  }
  
  return actions;
}

/**
 * Generate a descriptive label for a cluster
 * @param {string} clusterId - The cluster ID
 * @param {Array} entries - Entries in the cluster
 * @return {string} - A descriptive label
 */
function generateClusterLabel(clusterId, entries) {
  // Find the common models mentioned
  const allModels = entries.flatMap(entry => entry.modelMentions);
  const modelCounts = {};
  
  for (const model of allModels) {
    modelCounts[model] = (modelCounts[model] || 0) + 1;
  }
  
  // Sort models by frequency
  const sortedModels = Object.entries(modelCounts)
    .sort((a, b) => b[1] - a[1])
    .map(([model]) => model);
  
  // Get top models (limited to 2 for readability)
  const topModels = sortedModels.slice(0, 2);
  
  // Extract actions and capabilities
  const allContent = entries.map(entry => entry.content).join(" ");
  const capabilities = extractCapabilityMentions(allContent);
  const actions = extractActionMentions(allContent);
  
  // Count frequencies
  const capabilityCounts = {};
  for (const cap of capabilities) {
    capabilityCounts[cap] = (capabilityCounts[cap] || 0) + 1;
  }
  
  const actionCounts = {};
  for (const act of actions) {
    actionCounts[act] = (actionCounts[act] || 0) + 1;
  }
  
  // Get the most common capability and action
  const topCapability = Object.entries(capabilityCounts)
    .sort((a, b) => b[1] - a[1])
    .map(([cap]) => cap)[0] || "";
  
  const topAction = Object.entries(actionCounts)
    .sort((a, b) => b[1] - a[1])
    .map(([act]) => act)[0] || "";
  
  // Create a descriptive label
  let label = "";
  
  if (topModels.length > 0) {
    label += topModels.join("/");
  } else {
    label += "Unlabeled Topic";
  }
  
  if (topAction) {
    label += " - " + topAction;
  }
  
  if (topCapability) {
    label += " (" + topCapability + ")";
  }
  
  return label;
}

/**
 * Create a summary sheet with cluster information
 * @param {Object} clusters - Map of cluster IDs to arrays of entries
 */
function createClusterSummarySheet(clusters) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // Create or clear the summary sheet
  let summarySheet = ss.getSheetByName("Topic_Clusters");
  if (summarySheet) {
    summarySheet.clear();
  } else {
    summarySheet = ss.insertSheet("Topic_Clusters");
  }
  
  // Set up column headers
  summarySheet.getRange(1, 1, 1, 6).setValues([
    ["Cluster ID", "Label", "Entries", "Models", "Content Sample", "Rows"]
  ]);
  summarySheet.getRange(1, 1, 1, 6).setFontWeight("bold");
  
  // Sort clusters by size (largest first)
  const sortedClusters = Object.entries(clusters)
    .sort((a, b) => b[1].length - a[1].length);
  
  // Populate the sheet
  let rowIndex = 2;
  for (const [clusterId, entries] of sortedClusters) {
    // Skip clusters with only one entry
    if (entries.length < 2) continue;
    
    const label = generateClusterLabel(clusterId, entries);
    const allModels = Array.from(new Set(entries.flatMap(entry => entry.modelMentions))).join(", ");
    
    // Get a sample of content from the first entry
    const contentSample = entries[0].articleTitle || 
                          (entries[0].results ? entries[0].results.substring(0, 100) + "..." : "");
                          
    // Get row numbers
    const rows = entries.map(entry => entry.rowIndex).join(", ");
    
    summarySheet.getRange(rowIndex, 1, 1, 6).setValues([
      [clusterId, label, entries.length, allModels, contentSample, rows]
    ]);
    
    rowIndex++;
  }
  
  // Add a count of single-entry clusters at the bottom
  const singleEntries = sortedClusters
    .filter(([_, entries]) => entries.length === 1)
    .reduce((total, [_, entries]) => total + entries.length, 0);
  
  if (singleEntries > 0) {
    summarySheet.getRange(rowIndex, 1, 1, 3).setValues([
      ["UNCLUSTERED", "Individual topics (not clustered)", singleEntries]
    ]);
  }
  
  // Format the sheet
  summarySheet.autoResizeColumns(1, 6);
}

/**
 * Add topic clustering to the Research Log menu
 */
function updateMenuWithTopicClustering() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu with enhanced options
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addSeparator()
      .addItem('Enhance Research Log (All-in-One)', 'enhanceResearchLog')
      .addItem('Cluster by Topic', 'clusterResearchLogByTopic')
      .addSeparator()
      .addItem('Open Relevance Predictor (Sidebar)', 'showRelevancePredictorSidebar')
      .addItem('Test Relevance Predictor', 'testRelevancePrediction')
      .addSeparator()
      .addItem('Fix Column Alignment', 'fixColumnAlignment')
      .addSeparator()
      .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved')
      .addToUi();
  } catch (e) {
    console.log('Error creating Research Log menu: ' + e.message);
  }
}
/**
 * Fixed function to handle the validation message error
 * This updated function properly handles the data validation message
 */
function clusterResearchLogByTopicFixed() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      throw new Error("Research_Log sheet not found");
    }
    
    // Get all data and headers
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const columnIndices = {
      date: headers.indexOf("Date"),
      url: headers.indexOf("URL"),
      articleUrl: headers.indexOf("Article URL"),
      results: headers.indexOf("Results"),
      notes: headers.indexOf("Notes"),
      relevanceScore: headers.indexOf("Relevance Score"),
      topicCluster: headers.indexOf("Topic Cluster")
    };
    
    // Check if we have the main required columns
    if (columnIndices.results === -1) {
      throw new Error("Results column not found");
    }
    
    // Create a Topic Cluster column if it doesn't exist
    if (columnIndices.topicCluster === -1) {
      // Add the column after Notes or Relevance Score
      const insertAfterCol = columnIndices.relevanceScore !== -1 ? 
                           columnIndices.relevanceScore + 1 : 
                           (columnIndices.notes !== -1 ? 
                            columnIndices.notes + 1 : sheet.getLastColumn());
      
      sheet.insertColumnAfter(insertAfterCol);
      sheet.getRange(1, insertAfterCol + 1).setValue("Topic Cluster");
      
      // Update our indices
      columnIndices.topicCluster = insertAfterCol;
    }
    
    // Collect all entries that should be analyzed
    // Skip duplicates already identified
    const entriesToAnalyze = [];
    const skipRows = new Set(); // Rows to skip (duplicates)
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell)) continue;
      
      const notes = columnIndices.notes !== -1 ? row[columnIndices.notes] || "" : "";
      
      // Skip if this is marked as a duplicate
      if (notes.toString().includes("DUPLICATE of row")) {
        skipRows.add(i + 1); // 1-based row number
        continue;
      }
      
      const results = row[columnIndices.results] || "";
      
      // Skip if no results content
      if (!results) continue;
      
      // Extract model mentions and article title
      let modelMentions = extractModelMentions(results.toString());
      let articleTitle = extractArticleTitle(results.toString());
      
      entriesToAnalyze.push({
        rowIndex: i + 1, // 1-based row number
        results: results.toString(),
        notes: notes.toString(),
        articleTitle: articleTitle,
        modelMentions: modelMentions,
        content: results.toString() + " " + notes.toString()
      });
    }
    
    // Analyze and cluster the entries
    const clusters = performTopicClustering(entriesToAnalyze);
    
    // Apply clusters to the spreadsheet
    let clusterCount = 0;
    let rowsUpdated = 0;
    
    for (const [clusterId, entries] of Object.entries(clusters)) {
      if (entries.length > 1) { // Only consider actual clusters (more than 1 entry)
        clusterCount++;
        const clusterLabel = generateClusterLabel(clusterId, entries);
        
        // Update each entry in this cluster
        for (const entry of entries) {
          sheet.getRange(entry.rowIndex, columnIndices.topicCluster + 1).setValue(clusterLabel);
          rowsUpdated++;
        }
      }
    }
    
    // Create a summary of the clusters
    createClusterSummarySheet(clusters);
    
    // Display a summary message
    const unclustered = entriesToAnalyze.length - rowsUpdated;
    const message = `Topic Clustering Complete\n\n` +
                    `Found ${clusterCount} topic clusters\n` +
                    `${rowsUpdated} entries were assigned to clusters\n` +
                    `${unclustered} entries remain as individual topics\n` +
                    `${skipRows.size} duplicate entries were skipped\n\n` +
                    `A summary sheet "Topic_Clusters" has been created with details.`;
    
    SpreadsheetApp.getUi().alert('Research Log Clustering', message, SpreadsheetApp.getUi().ButtonSet.OK);
    
    return {
      clusterCount,
      rowsUpdated,
      unclustered,
      duplicatesSkipped: skipRows.size
    };
    
  } catch (error) {
    // Convert validation message to a more user-friendly message
    let errorMessage = error.message;
    
    // Check if this is the validation message we're getting
    if (errorMessage.includes("Rate relevance:") && 
        errorMessage.includes("irrelevant") && 
        errorMessage.includes("highly relevant")) {
      // This is just the validation message for the relevance score column
      // We can safely proceed with clustering
      console.log("Ignoring validation message: " + errorMessage);
      
      // Show a friendlier message to the user
      SpreadsheetApp.getUi().alert(
        'Topic Clustering',
        'The clustering process encountered a validation message but will continue. ' +
        'This does not affect the clustering results.',
        SpreadsheetApp.getUi().ButtonSet.OK
      );
      
      // Try to run the clustering again, bypassing the validation error
      return runClusteringWithoutValidation();
    } else {
      // This is a different error, show it to the user
      console.log(`Error clustering Research Log: ${errorMessage}`);
      SpreadsheetApp.getUi().alert('Error', `Error clustering Research Log: ${errorMessage}`, SpreadsheetApp.getUi().ButtonSet.OK);
      return {
        error: errorMessage
      };
    }
  }
}

/**
 * Run the clustering without validation checks
 * This is a simplified version that skips some validation
 */
function runClusteringWithoutValidation() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Research_Log");
    
    if (!sheet) {
      return { error: "Research_Log sheet not found" };
    }
    
    // Get all data and headers
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find key columns by name
    let resultsColIndex = -1;
    let notesColIndex = -1;
    let topicClusterColIndex = -1;
    
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString();
      if (header === "Results") resultsColIndex = i;
      if (header === "Notes") notesColIndex = i;
      if (header === "Topic Cluster") topicClusterColIndex = i;
    }
    
    // Add Topic Cluster column if needed
    if (topicClusterColIndex === -1) {
      const insertAfterCol = headers.length;
      sheet.insertColumnAfter(insertAfterCol);
      sheet.getRange(1, insertAfterCol + 1).setValue("Topic Cluster");
      topicClusterColIndex = insertAfterCol;
    }
    
    // Collect entries to analyze
    const entriesToAnalyze = [];
    const skipRows = new Set();
    
    for (let i =.1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows
      if (!row.some(cell => cell !== "")) continue;
      
      // Check if this is a duplicate
      const notes = notesColIndex >= 0 ? row[notesColIndex] || "" : "";
      if (notes.toString().includes("DUPLICATE")) {
        skipRows.add(i + 1);
        continue;
      }
      
      // Get results
      const results = resultsColIndex >= 0 ? row[resultsColIndex] || "" : "";
      if (!results) continue;
      
      // Add to entries
      entriesToAnalyze.push({
        rowIndex: i + 1,
        results: results.toString(),
        notes: notes.toString(),
        articleTitle: extractArticleTitle(results.toString()),
        modelMentions: extractModelMentions(results.toString()),
        content: results.toString() + " " + notes.toString()
      });
    }
    
    // Simple grouping by model mention first
    const modelGroups = {};
    
    for (const entry of entriesToAnalyze) {
      // Skip entries with no model mentions
      if (!entry.modelMentions || entry.modelMentions.length === 0) continue;
      
      // Create a key from the models
      const key = entry.modelMentions.sort().join('|');
      
      if (!modelGroups[key]) {
        modelGroups[key] = [];
      }
      
      modelGroups[key].push(entry);
    }
    
    // Apply clusters to the spreadsheet
    let clusterCount = 0;
    let rowsUpdated = 0;
    
    // Process each model group
    for (const [modelKey, entries] of Object.entries(modelGroups)) {
      if (entries.length > 1) {
        clusterCount++;
        
        // Generate a simple label
        const label = entries[0].modelMentions.join('/') + " cluster";
        
        // Update each entry
        for (const entry of entries) {
          sheet.getRange(entry.rowIndex, topicClusterColIndex + 1).setValue(label);
          rowsUpdated++;
        }
      }
    }
    
    // Show summary
    const message = `Basic Topic Clustering Complete\n\n` +
                   `Found ${clusterCount} basic model clusters\n` +
                   `${rowsUpdated} entries were assigned to clusters\n` +
                   `${entriesToAnalyze.length - rowsUpdated} entries remain unclustered\n` +
                   `${skipRows.size} duplicate entries were skipped`;
    
    SpreadsheetApp.getUi().alert('Topic Clustering Results', message, SpreadsheetApp.getUi().ButtonSet.OK);
    
    return {
      clusterCount,
      rowsUpdated,
      unclustered: entriesToAnalyze.length - rowsUpdated,
      duplicatesSkipped: skipRows.size
    };
  } catch (error) {
    console.log(`Error in fallback clustering: ${error.message}`);
    SpreadsheetApp.getUi().alert('Error', `Error in fallback clustering: ${error.message}`, SpreadsheetApp.getUi().ButtonSet.OK);
    return { error: error.message };
  }
}

/**
 * Update the menu with the fixed clustering function
 */
function updateMenuWithFixedTopicClustering() {
  try {
    const ui = SpreadsheetApp.getUi();
    
    // Research Log menu with enhanced options
    ui.createMenu('Research Log')
      .addItem('Setup Relevance Tracking', 'setupResearchLogRelevanceTracking')
      .addItem('Apply Relevance Learning', 'applyRelevanceLearningToKeywords')
      .addItem('Assess Current Entry', 'prepareCurrentEntryRelevance')
      .addSeparator()
      .addItem('Enhance Research Log (All-in-One)', 'enhanceResearchLog')
      .addItem('Cluster by Topic (Fixed)', 'clusterResearchLogByTopicFixed')
      .addSeparator()
      .addItem('Open Relevance Predictor (Sidebar)', 'showRelevancePredictorSidebar')
      .addItem('Test Relevance Predictor', 'testRelevancePrediction')
      .addSeparator()
      .addItem('Fix Column Alignment', 'fixColumnAlignment')
      .addSeparator()
      .addItem('Extract Article URLs (Improved)', 'extractArticleURLsImproved')
      .addToUi();
  } catch (e) {
    console.log('Error creating Research Log menu: ' + e.message);
  }
}
